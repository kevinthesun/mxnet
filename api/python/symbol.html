<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Symbol API — mxnet  documentation</title>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" rel="stylesheet"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="../../_static/basic.css" rel="stylesheet" type="text/css">
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../_static/mxnet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: ''
      };
    </script>
<script src="../../_static/jquery-1.11.1.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/searchtools_custom.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/selectlang.js" type="text/javascript"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/javascript"> jQuery(function() { Search.loadIndex("/searchindex.js"); Search.init();}); </script>
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
      Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96378503-1', 'auto');
      ga('send', 'pageview');

    </script>
<!-- -->
<!-- <script type="text/javascript" src="../../_static/jquery.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../_static/underscore.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../_static/doctools.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<!-- -->
<link href="index.html" rel="up" title="MXNet - Python API">
<link href="module.html" rel="next" title="Module API"/>
<link href="ndarray.html" rel="prev" title="NDArray API"/>
<link href="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-icon.png" rel="icon" type="image/png"/>
</link></link></link></head>
<body role="document"><!-- Previous Navbar Layout
<div class="navbar navbar-default navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../../" class="navbar-brand">
        <img src="http://data.mxnet.io/theme/mxnet.png">
      </a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul id="navbar" class="navbar navbar-left">
        
        <li> <a href="../../get_started/index.html">Get Started</a> </li>
        
        <li> <a href="../../tutorials/index.html">Tutorials</a> </li>
        
        <li> <a href="../../how_to/index.html">How To</a> </li>
        
        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">Packages <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
            <li><a href="../../packages/python/index.html">
                Python
            </a></li>
            
            <li><a href="../../packages/r/index.html">
                R
            </a></li>
            
            <li><a href="../../packages/julia/index.html">
                Julia
            </a></li>
            
            <li><a href="../../packages/c++/index.html">
                C++
            </a></li>
            
            <li><a href="../../packages/scala/index.html">
                Scala
            </a></li>
            
            <li><a href="../../packages/perl/index.html">
                Perl
            </a></li>
            
          </ul>
        </li>
        
        <li> <a href="../../system/index.html">System</a> </li>
        <li> 
<form class="" role="search" action="../../search.html" method="get" autocomplete="off">
  <div class="form-group inner-addon left-addon">
    <i class="glyphicon glyphicon-search"></i>
    <input type="text" name="q" class="form-control" placeholder="Search">
  </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
  
</form> </li>
      </ul>
      <ul id="navbar" class="navbar navbar-right">
        <li> <a href="../../index.html"><span class="flag-icon flag-icon-us"></span></a> </li>
        <li> <a href="../..//zh/index.html"><span class="flag-icon flag-icon-cn"></span></a> </li>
      </ul>
    </div>
  </div>
</div>
Previous Navbar Layout End -->
<div class="navbar navbar-fixed-top">
<div class="container" id="navContainer">
<div class="innder" id="header-inner">
<h1 id="logo-wrap">
<a href="../../" id="logo"><img src="http://data.mxnet.io/theme/mxnet.png"/></a>
</h1>
<nav class="nav-bar" id="main-nav">
<a class="main-nav-link" href="../../get_started/install.html">Install</a>
<a class="main-nav-link" href="../../tutorials/index.html">Tutorials</a>
<a class="main-nav-link" href="../../how_to/index.html">How To</a>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">API <span class="caret"></span></a>
<ul class="dropdown-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="../../api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="../../api/scala/index.html">Scala</a></li>
<li><a class="main-nav-link" href="../../api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="../../api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="../../api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="../../api/perl/index.html">Perl</a></li>
</ul>
</span>
<a class="main-nav-link" href="../../architecture/index.html">Architecture</a>
<!-- <a class="main-nav-link" href="../../community/index.html">Community</a> -->
<a class="main-nav-link" href="https://github.com/dmlc/mxnet">Github</a>
<span id="dropdown-menu-position-anchor-version" style="position: relative"><a href="#" class="main-nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">Versions(v0.22.0test)<span class="caret"></span></a><ul id="package-dropdown-menu" class="dropdown-menu"><li><a class="main-nav-link" href=http://localhost:8008/>v0.22.0test</a></li><li><a class="main-nav-link" href=http://localhost:8008/versions/v0.19.0test/index.html>v0.19.0test</a></li><li><a class="main-nav-link" href=http://localhost:8008/versions/0.10/index.html>0.10</a></li><li><a class="main-nav-link" href=http://localhost:8008/versions/master/index.html>master</a></li></ul></span></nav>
<script> function getRootPath(){ return "../../" } </script>
<div class="burgerIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button">☰</a>
<ul class="dropdown-menu dropdown-menu-right" id="burgerMenu">
<li><a href="../../get_started/install.html">Install</a></li>
<li><a href="../../tutorials/index.html">Tutorials</a></li>
<li><a href="../../how_to/index.html">How To</a></li>
<li class="dropdown-submenu">
<a href="#" tabindex="-1">API</a>
<ul class="dropdown-menu">
<li><a href="../../api/python/index.html" tabindex="-1">Python</a>
</li>
<li><a href="../../api/scala/index.html" tabindex="-1">Scala</a>
</li>
<li><a href="../../api/r/index.html" tabindex="-1">R</a>
</li>
<li><a href="../../api/julia/index.html" tabindex="-1">Julia</a>
</li>
<li><a href="../../api/c++/index.html" tabindex="-1">C++</a>
</li>
<li><a href="../../api/perl/index.html" tabindex="-1">Perl</a>
</li>
</ul>
</li>
<li><a href="../../architecture/index.html">Architecture</a></li>
<li><a class="main-nav-link" href="https://github.com/dmlc/mxnet">Github</a></li>
<li id="dropdown-menu-position-anchor-version-mobile" class="dropdown-submenu" style="position: relative"><a href="#" tabindex="-1">Versions(v0.22.0test)</a><ul class="dropdown-menu"><li><a tabindex="-1" href=http://localhost:8008/>v0.22.0test</a></li><li><a tabindex="-1" href=http://localhost:8008/versions/v0.19.0test/index.html>v0.19.0test</a></li><li><a tabindex="-1" href=http://localhost:8008/versions/0.10/index.html>0.10</a></li><li><a tabindex="-1" href=http://localhost:8008/versions/master/index.html>master</a></li></ul></li></ul>
</div>
<div class="plusIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button"><span aria-hidden="true" class="glyphicon glyphicon-plus"></span></a>
<ul class="dropdown-menu dropdown-menu-right" id="plusMenu"></ul>
</div>
<div id="search-input-wrap">
<form action="../../search.html" autocomplete="off" class="" method="get" role="search">
<div class="form-group inner-addon left-addon">
<i class="glyphicon glyphicon-search"></i>
<input class="form-control" name="q" placeholder="Search" type="text"/>
</div>
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default"/>
</input></form>
<div id="search-preview"></div>
</div>
<div id="searchIcon">
<span aria-hidden="true" class="glyphicon glyphicon-search"></span>
</div>
<!-- <div id="lang-select-wrap"> -->
<!--   <label id="lang-select-label"> -->
<!--     <\!-- <i class="fa fa-globe"></i> -\-> -->
<!--     <span></span> -->
<!--   </label> -->
<!--   <select id="lang-select"> -->
<!--     <option value="en">Eng</option> -->
<!--     <option value="zh">中文</option> -->
<!--   </select> -->
<!-- </div> -->
<!--     <a id="mobile-nav-toggle">
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
      </a> -->
</div>
</div>
</div>
<div class="container">
<div class="row">
<div aria-label="main navigation" class="sphinxsidebar leftsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Python Documents</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#table-of-contents">Table of contents</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ndarray.html">NDArray API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Symbol API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-symbol-class">The <code class="docutils literal"><span class="pre">Symbol</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#symbol-creation-routines">Symbol creation routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#symbol-manipulation-routines">Symbol manipulation routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mathematical-functions">Mathematical functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#neural-network">Neural network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="module.html">Module API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gluon.html">Gluon Package</a></li>
<li class="toctree-l3"><a class="reference internal" href="rnn.html">RNN Cell API</a></li>
<li class="toctree-l3"><a class="reference internal" href="kvstore.html">KVStore API</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Data Loading API</a></li>
<li class="toctree-l3"><a class="reference internal" href="image.html">Image API</a></li>
<li class="toctree-l3"><a class="reference internal" href="optimization.html">Optimization: initialize and update weights</a></li>
<li class="toctree-l3"><a class="reference internal" href="callback.html">Callback API</a></li>
<li class="toctree-l3"><a class="reference internal" href="metric.html">Evaluation Metric API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../r/index.html">R Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../julia/index.html">Julia Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c++/index.html">C++ Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scala/index.html">Scala Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../perl/index.html">Perl Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to/index.html">HowTo Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture/index.html">System Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
</ul>
</div>
</div>
<div class="content">
<div class="section" id="symbol-api">
<span id="symbol-api"></span><h1>Symbol API<a class="headerlink" href="#symbol-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This document lists the routines of the symbolic expression package:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#module-mxnet.symbol" title="mxnet.symbol"><code class="xref py py-obj docutils literal"><span class="pre">mxnet.symbol</span></code></a></td>
<td>Symbolic configuration API of MXNet.</td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal"><span class="pre">Symbol</span></code> API, defined in the <code class="docutils literal"><span class="pre">symbol</span></code> (or simply <code class="docutils literal"><span class="pre">sym</span></code>) package, provides
neural network graphs and auto-differentiation.
A symbol represents a multi-output symbolic expression.
They are composited by operators, such as simple matrix operations (e.g. “+”),
or a neural network layer (e.g. convolution layer).
An operator can take several input variables,
produce more than one output variables, and have internal state variables.
A variable can be either free, which we can bind with value later,
or an output of another symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go"><class 'mxnet.symbol.Symbol'></span>
<span class="gp">>>> </span><span class="n">e</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="s1">'b'</span><span class="p">:</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])})</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">y</span>
<span class="go">[<NDArray 2 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 4.,  7.], dtype=float32)</span>
</pre></div>
</div>
<p>A detailed tutorial is available at <a class="reference external" href="http://mxnet.io/tutorials/basic/symbol.html">Symbol - Neural network graphs and auto-differentiation</a>.
<br/><br/></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>most operators provided in <code class="docutils literal"><span class="pre">symbol</span></code> are similar to those in <code class="docutils literal"><span class="pre">ndarray</span></code>
although there are few differences:</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">symbol</span></code> adopts declarative programming. In other words, we need to first
compose the computations, and then feed it with data for execution whereas
ndarray adopts imperative programming.</li>
<li>Most binary operators in <code class="docutils literal"><span class="pre">symbol</span></code> such as <code class="docutils literal"><span class="pre">+</span></code> and <code class="docutils literal"><span class="pre">></span></code> don’t broadcast.
We need to call the broadcast version of the operator such as <code class="docutils literal"><span class="pre">broadcast_plus</span></code>
explicitly.</li>
</ul>
</div>
<p>In the rest of this document, we first overview the methods provided by the
<code class="docutils literal"><span class="pre">symbol.Symbol</span></code> class, and then list other routines provided by the
<code class="docutils literal"><span class="pre">symbol</span></code> package.</p>
</div>
<div class="section" id="the-symbol-class">
<span id="the-symbol-class"></span><h2>The <code class="docutils literal"><span class="pre">Symbol</span></code> class<a class="headerlink" href="#the-symbol-class" title="Permalink to this headline">¶</a></h2>
<div class="section" id="composition">
<span id="composition"></span><h3>Composition<a class="headerlink" href="#composition" title="Permalink to this headline">¶</a></h3>
<p>Composite multiple symbols into a new one by an operator.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__call__" title="mxnet.symbol.Symbol.__call__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__call__</span></code></a></td>
<td>Composes symbol using inputs.</td>
</tr>
</tbody>
</table>
<div class="section" id="arithmetic-operations">
<span id="arithmetic-operations"></span><h4>Arithmetic operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this headline">¶</a></h4>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__add__" title="mxnet.symbol.Symbol.__add__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__add__</span></code></a></td>
<td>x.__add__(y) <=> x+y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__sub__" title="mxnet.symbol.Symbol.__sub__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__sub__</span></code></a></td>
<td>x.__sub__(y) <=> x-y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__rsub__" title="mxnet.symbol.Symbol.__rsub__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__rsub__</span></code></a></td>
<td>x.__rsub__(y) <=> y-x</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__neg__" title="mxnet.symbol.Symbol.__neg__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__neg__</span></code></a></td>
<td>x.__neg__() <=> -x</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__mul__" title="mxnet.symbol.Symbol.__mul__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__mul__</span></code></a></td>
<td>x.__mul__(y) <=> x*y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__div__" title="mxnet.symbol.Symbol.__div__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__div__</span></code></a></td>
<td>x.__div__(y) <=> x/y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__rdiv__" title="mxnet.symbol.Symbol.__rdiv__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__rdiv__</span></code></a></td>
<td>x.__rdiv__(y) <=> y/x</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__mod__" title="mxnet.symbol.Symbol.__mod__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__mod__</span></code></a></td>
<td>x.__mod__(y) <=> x%y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__rmod__" title="mxnet.symbol.Symbol.__rmod__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__rmod__</span></code></a></td>
<td>x.__rmod__(y) <=> y%x</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__pow__" title="mxnet.symbol.Symbol.__pow__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__pow__</span></code></a></td>
<td>x.__pow__(y) <=> x**y</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="comparison-operators">
<span id="comparison-operators"></span><h4>Comparison operators<a class="headerlink" href="#comparison-operators" title="Permalink to this headline">¶</a></h4>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__lt__" title="mxnet.symbol.Symbol.__lt__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__lt__</span></code></a></td>
<td>x.__lt__(y) <=> x<y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__le__" title="mxnet.symbol.Symbol.__le__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__le__</span></code></a></td>
<td>x.__le__(y) <=> x<=y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__gt__" title="mxnet.symbol.Symbol.__gt__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__gt__</span></code></a></td>
<td>x.__gt__(y) <=> x>y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__ge__" title="mxnet.symbol.Symbol.__ge__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__ge__</span></code></a></td>
<td>x.__ge__(y) <=> x>=y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__eq__" title="mxnet.symbol.Symbol.__eq__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__eq__</span></code></a></td>
<td>x.__eq__(y) <=> x==y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__ne__" title="mxnet.symbol.Symbol.__ne__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__ne__</span></code></a></td>
<td>x.__ne__(y) <=> x!=y</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="query-information">
<span id="query-information"></span><h3>Query information<a class="headerlink" href="#query-information" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.name" title="mxnet.symbol.Symbol.name"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.name</span></code></a></td>
<td>Gets name string from the symbol, this function only works for non-grouped symbol.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.list_arguments" title="mxnet.symbol.Symbol.list_arguments"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.list_arguments</span></code></a></td>
<td>Lists all the arguments in the symbol.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.list_outputs" title="mxnet.symbol.Symbol.list_outputs"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.list_outputs</span></code></a></td>
<td>Lists all the outputs in the symbol.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.list_auxiliary_states" title="mxnet.symbol.Symbol.list_auxiliary_states"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.list_auxiliary_states</span></code></a></td>
<td>Lists all the auxiliary states in the symbol.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.list_attr" title="mxnet.symbol.Symbol.list_attr"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.list_attr</span></code></a></td>
<td>Gets all attributes from the symbol.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.attr" title="mxnet.symbol.Symbol.attr"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.attr</span></code></a></td>
<td>Returns the attribute string for corresponding input key from the symbol.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.attr_dict" title="mxnet.symbol.Symbol.attr_dict"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.attr_dict</span></code></a></td>
<td>Recursively gets all attributes from the symbol and its children.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-internal-and-output-symbol">
<span id="get-internal-and-output-symbol"></span><h3>Get internal and output symbol<a class="headerlink" href="#get-internal-and-output-symbol" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__getitem__" title="mxnet.symbol.Symbol.__getitem__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__getitem__</span></code></a></td>
<td>x.__getitem__(i) <=> x[i]</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.__iter__" title="mxnet.symbol.Symbol.__iter__"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.__iter__</span></code></a></td>
<td>Returns a generator object of symbol.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.get_internals" title="mxnet.symbol.Symbol.get_internals"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.get_internals</span></code></a></td>
<td>Gets a new grouped symbol <cite>sgroup</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.get_children" title="mxnet.symbol.Symbol.get_children"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.get_children</span></code></a></td>
<td>Gets a new grouped symbol whose output contains inputs to output nodes of the original symbol.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="inference-type-and-shape">
<span id="inference-type-and-shape"></span><h3>Inference type and shape<a class="headerlink" href="#inference-type-and-shape" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.infer_type" title="mxnet.symbol.Symbol.infer_type"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.infer_type</span></code></a></td>
<td>Infers the type of all arguments and all outputs, given the known types for some arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.infer_shape" title="mxnet.symbol.Symbol.infer_shape"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.infer_shape</span></code></a></td>
<td>Infers the shapes of all arguments and all outputs given the known shapes of some arguments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.infer_shape_partial" title="mxnet.symbol.Symbol.infer_shape_partial"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.infer_shape_partial</span></code></a></td>
<td>Infers the shape partially.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bind">
<span id="bind"></span><h3>Bind<a class="headerlink" href="#bind" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.bind" title="mxnet.symbol.Symbol.bind"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.bind</span></code></a></td>
<td>Binds the current symbol to an executor and returns it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.simple_bind" title="mxnet.symbol.Symbol.simple_bind"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.simple_bind</span></code></a></td>
<td>Bind current symbol to get an executor, allocate all the arguments needed.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="save">
<span id="save"></span><h3>Save<a class="headerlink" href="#save" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.save" title="mxnet.symbol.Symbol.save"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.save</span></code></a></td>
<td>Saves symbol to a file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Symbol.tojson" title="mxnet.symbol.Symbol.tojson"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.tojson</span></code></a></td>
<td>Saves symbol to a JSON string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Symbol.debug_str" title="mxnet.symbol.Symbol.debug_str"><code class="xref py py-obj docutils literal"><span class="pre">Symbol.debug_str</span></code></a></td>
<td>Gets a debug string of symbol.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="symbol-creation-routines">
<span id="symbol-creation-routines"></span><h2>Symbol creation routines<a class="headerlink" href="#symbol-creation-routines" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.var" title="mxnet.symbol.var"><code class="xref py py-obj docutils literal"><span class="pre">var</span></code></a></td>
<td>Creates a symbolic variable with specified name.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.zeros" title="mxnet.symbol.zeros"><code class="xref py py-obj docutils literal"><span class="pre">zeros</span></code></a></td>
<td>Returns a new symbol of given shape and type, filled with zeros.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.ones" title="mxnet.symbol.ones"><code class="xref py py-obj docutils literal"><span class="pre">ones</span></code></a></td>
<td>Returns a new symbol of given shape and type, filled with ones.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.arange" title="mxnet.symbol.arange"><code class="xref py py-obj docutils literal"><span class="pre">arange</span></code></a></td>
<td>Returns evenly spaced values within a given interval.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="symbol-manipulation-routines">
<span id="symbol-manipulation-routines"></span><h2>Symbol manipulation routines<a class="headerlink" href="#symbol-manipulation-routines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="changing-shape-and-type">
<span id="changing-shape-and-type"></span><h3>Changing shape and type<a class="headerlink" href="#changing-shape-and-type" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.cast" title="mxnet.symbol.cast"><code class="xref py py-obj docutils literal"><span class="pre">cast</span></code></a></td>
<td>Casts all elements of the input to a new type.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.reshape" title="mxnet.symbol.reshape"><code class="xref py py-obj docutils literal"><span class="pre">reshape</span></code></a></td>
<td>Reshapes the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.flatten" title="mxnet.symbol.flatten"><code class="xref py py-obj docutils literal"><span class="pre">flatten</span></code></a></td>
<td>Flattens the input array into a 2-D array by collapsing the higher dimensions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.expand_dims" title="mxnet.symbol.expand_dims"><code class="xref py py-obj docutils literal"><span class="pre">expand_dims</span></code></a></td>
<td>Inserts a new axis of size 1 into the array shape</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="expanding-elements">
<span id="expanding-elements"></span><h3>Expanding elements<a class="headerlink" href="#expanding-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_to" title="mxnet.symbol.broadcast_to"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_to</span></code></a></td>
<td>Broadcasts the input array to a new shape.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_axes" title="mxnet.symbol.broadcast_axes"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_axes</span></code></a></td>
<td>Broadcasts the input array over particular axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.repeat" title="mxnet.symbol.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a></td>
<td>Repeats elements of an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.tile" title="mxnet.symbol.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a></td>
<td>Repeats the whole array multiple times.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.pad" title="mxnet.symbol.pad"><code class="xref py py-obj docutils literal"><span class="pre">pad</span></code></a></td>
<td>Pads an input array with a constant or edge values of the array.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rearranging-elements">
<span id="rearranging-elements"></span><h3>Rearranging elements<a class="headerlink" href="#rearranging-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.transpose" title="mxnet.symbol.transpose"><code class="xref py py-obj docutils literal"><span class="pre">transpose</span></code></a></td>
<td>Permutes the dimensions of an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.swapaxes" title="mxnet.symbol.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></code></a></td>
<td>Interchanges two axes of an array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.flip" title="mxnet.symbol.flip"><code class="xref py py-obj docutils literal"><span class="pre">flip</span></code></a></td>
<td>Reverses the order of elements along given axis while preserving array shape.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="joining-and-splitting-symbols">
<span id="joining-and-splitting-symbols"></span><h3>Joining and splitting symbols<a class="headerlink" href="#joining-and-splitting-symbols" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.concat" title="mxnet.symbol.concat"><code class="xref py py-obj docutils literal"><span class="pre">concat</span></code></a></td>
<td>Joins input arrays along a given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.split" title="mxnet.symbol.split"><code class="xref py py-obj docutils literal"><span class="pre">split</span></code></a></td>
<td>Splits an array along a particular axis into multiple sub-arrays.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="indexing-routines">
<span id="indexing-routines"></span><h3>Indexing routines<a class="headerlink" href="#indexing-routines" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.slice" title="mxnet.symbol.slice"><code class="xref py py-obj docutils literal"><span class="pre">slice</span></code></a></td>
<td>Slices a contiguous region of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.slice_axis" title="mxnet.symbol.slice_axis"><code class="xref py py-obj docutils literal"><span class="pre">slice_axis</span></code></a></td>
<td>Slices along a given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.take" title="mxnet.symbol.take"><code class="xref py py-obj docutils literal"><span class="pre">take</span></code></a></td>
<td>Takes elements from an input array along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.batch_take" title="mxnet.symbol.batch_take"><code class="xref py py-obj docutils literal"><span class="pre">batch_take</span></code></a></td>
<td>Takes elements from a data batch.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.one_hot" title="mxnet.symbol.one_hot"><code class="xref py py-obj docutils literal"><span class="pre">one_hot</span></code></a></td>
<td>Returns a one-hot array.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="mathematical-functions">
<span id="mathematical-functions"></span><h2>Mathematical functions<a class="headerlink" href="#mathematical-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="arithmetic-operations">
<span id="id1"></span><h3>Arithmetic operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_add" title="mxnet.symbol.broadcast_add"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_add</span></code></a></td>
<td>Returns element-wise sum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_sub" title="mxnet.symbol.broadcast_sub"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_sub</span></code></a></td>
<td>Returns element-wise difference of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_mul" title="mxnet.symbol.broadcast_mul"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_mul</span></code></a></td>
<td>Returns element-wise product of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_div" title="mxnet.symbol.broadcast_div"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_div</span></code></a></td>
<td>Returns element-wise division of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_mod" title="mxnet.symbol.broadcast_mod"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_mod</span></code></a></td>
<td>Returns element-wise modulo of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.negative" title="mxnet.symbol.negative"><code class="xref py py-obj docutils literal"><span class="pre">negative</span></code></a></td>
<td>Numerical negative of the argument, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.reciprocal" title="mxnet.symbol.reciprocal"><code class="xref py py-obj docutils literal"><span class="pre">reciprocal</span></code></a></td>
<td>Returns the reciprocal of the argument, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.dot" title="mxnet.symbol.dot"><code class="xref py py-obj docutils literal"><span class="pre">dot</span></code></a></td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.batch_dot" title="mxnet.symbol.batch_dot"><code class="xref py py-obj docutils literal"><span class="pre">batch_dot</span></code></a></td>
<td>Batchwise dot product.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.add_n" title="mxnet.symbol.add_n"><code class="xref py py-obj docutils literal"><span class="pre">add_n</span></code></a></td>
<td>Adds all input arguments element-wise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="trigonometric-functions">
<span id="trigonometric-functions"></span><h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sin" title="mxnet.symbol.sin"><code class="xref py py-obj docutils literal"><span class="pre">sin</span></code></a></td>
<td>Computes the element-wise sine of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.cos" title="mxnet.symbol.cos"><code class="xref py py-obj docutils literal"><span class="pre">cos</span></code></a></td>
<td>Computes the element-wise cosine of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.tan" title="mxnet.symbol.tan"><code class="xref py py-obj docutils literal"><span class="pre">tan</span></code></a></td>
<td>Computes the element-wise tangent of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.arcsin" title="mxnet.symbol.arcsin"><code class="xref py py-obj docutils literal"><span class="pre">arcsin</span></code></a></td>
<td>Returns element-wise inverse sine of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.arccos" title="mxnet.symbol.arccos"><code class="xref py py-obj docutils literal"><span class="pre">arccos</span></code></a></td>
<td>Returns element-wise inverse cosine of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.arctan" title="mxnet.symbol.arctan"><code class="xref py py-obj docutils literal"><span class="pre">arctan</span></code></a></td>
<td>Returns element-wise inverse tangent of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.hypot" title="mxnet.symbol.hypot"><code class="xref py py-obj docutils literal"><span class="pre">hypot</span></code></a></td>
<td>Given the “legs” of a right triangle, returns its hypotenuse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_hypot" title="mxnet.symbol.broadcast_hypot"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_hypot</span></code></a></td>
<td>Returns the hypotenuse of a right angled triangle, given its “legs” with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.degrees" title="mxnet.symbol.degrees"><code class="xref py py-obj docutils literal"><span class="pre">degrees</span></code></a></td>
<td>Converts each element of the input array from radians to degrees.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.radians" title="mxnet.symbol.radians"><code class="xref py py-obj docutils literal"><span class="pre">radians</span></code></a></td>
<td>Converts each element of the input array from degrees to radians.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hyperbolic-functions">
<span id="hyperbolic-functions"></span><h3>Hyperbolic functions<a class="headerlink" href="#hyperbolic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sinh" title="mxnet.symbol.sinh"><code class="xref py py-obj docutils literal"><span class="pre">sinh</span></code></a></td>
<td>Returns the hyperbolic sine of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.cosh" title="mxnet.symbol.cosh"><code class="xref py py-obj docutils literal"><span class="pre">cosh</span></code></a></td>
<td>Returns the hyperbolic cosine  of the input array, computed element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.tanh" title="mxnet.symbol.tanh"><code class="xref py py-obj docutils literal"><span class="pre">tanh</span></code></a></td>
<td>Returns the hyperbolic tangent of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.arcsinh" title="mxnet.symbol.arcsinh"><code class="xref py py-obj docutils literal"><span class="pre">arcsinh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.arccosh" title="mxnet.symbol.arccosh"><code class="xref py py-obj docutils literal"><span class="pre">arccosh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.arctanh" title="mxnet.symbol.arctanh"><code class="xref py py-obj docutils literal"><span class="pre">arctanh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reduce-functions">
<span id="reduce-functions"></span><h3>Reduce functions<a class="headerlink" href="#reduce-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sum" title="mxnet.symbol.sum"><code class="xref py py-obj docutils literal"><span class="pre">sum</span></code></a></td>
<td>Computes the sum of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.nansum" title="mxnet.symbol.nansum"><code class="xref py py-obj docutils literal"><span class="pre">nansum</span></code></a></td>
<td>Computes the sum of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as zero.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.prod" title="mxnet.symbol.prod"><code class="xref py py-obj docutils literal"><span class="pre">prod</span></code></a></td>
<td>Computes the product of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.nanprod" title="mxnet.symbol.nanprod"><code class="xref py py-obj docutils literal"><span class="pre">nanprod</span></code></a></td>
<td>Computes the product of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as one.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.mean" title="mxnet.symbol.mean"><code class="xref py py-obj docutils literal"><span class="pre">mean</span></code></a></td>
<td>Computes the mean of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.max" title="mxnet.symbol.max"><code class="xref py py-obj docutils literal"><span class="pre">max</span></code></a></td>
<td>Computes the max of array elements over given axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.min" title="mxnet.symbol.min"><code class="xref py py-obj docutils literal"><span class="pre">min</span></code></a></td>
<td>Computes the min of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.norm" title="mxnet.symbol.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a></td>
<td>Flattens the input array and then computes the l2 norm.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rounding">
<span id="rounding"></span><h3>Rounding<a class="headerlink" href="#rounding" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.round" title="mxnet.symbol.round"><code class="xref py py-obj docutils literal"><span class="pre">round</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.rint" title="mxnet.symbol.rint"><code class="xref py py-obj docutils literal"><span class="pre">rint</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.fix" title="mxnet.symbol.fix"><code class="xref py py-obj docutils literal"><span class="pre">fix</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer towards zero of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.floor" title="mxnet.symbol.floor"><code class="xref py py-obj docutils literal"><span class="pre">floor</span></code></a></td>
<td>Returns element-wise floor of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.ceil" title="mxnet.symbol.ceil"><code class="xref py py-obj docutils literal"><span class="pre">ceil</span></code></a></td>
<td>Returns element-wise ceiling of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.trunc" title="mxnet.symbol.trunc"><code class="xref py py-obj docutils literal"><span class="pre">trunc</span></code></a></td>
<td>Return the element-wise truncated value of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="exponents-and-logarithms">
<span id="exponents-and-logarithms"></span><h3>Exponents and logarithms<a class="headerlink" href="#exponents-and-logarithms" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.exp" title="mxnet.symbol.exp"><code class="xref py py-obj docutils literal"><span class="pre">exp</span></code></a></td>
<td>Returns element-wise exponential value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.expm1" title="mxnet.symbol.expm1"><code class="xref py py-obj docutils literal"><span class="pre">expm1</span></code></a></td>
<td>Returns <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> computed element-wise on the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.log" title="mxnet.symbol.log"><code class="xref py py-obj docutils literal"><span class="pre">log</span></code></a></td>
<td>Returns element-wise Natural logarithmic value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.log10" title="mxnet.symbol.log10"><code class="xref py py-obj docutils literal"><span class="pre">log10</span></code></a></td>
<td>Returns element-wise Base-10 logarithmic value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.log2" title="mxnet.symbol.log2"><code class="xref py py-obj docutils literal"><span class="pre">log2</span></code></a></td>
<td>Returns element-wise Base-2 logarithmic value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.log1p" title="mxnet.symbol.log1p"><code class="xref py py-obj docutils literal"><span class="pre">log1p</span></code></a></td>
<td>Returns element-wise <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code> value of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="powers">
<span id="powers"></span><h3>Powers<a class="headerlink" href="#powers" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_power" title="mxnet.symbol.broadcast_power"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_power</span></code></a></td>
<td>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.sqrt" title="mxnet.symbol.sqrt"><code class="xref py py-obj docutils literal"><span class="pre">sqrt</span></code></a></td>
<td>Returns element-wise square-root value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.rsqrt" title="mxnet.symbol.rsqrt"><code class="xref py py-obj docutils literal"><span class="pre">rsqrt</span></code></a></td>
<td>Returns element-wise inverse square-root value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.square" title="mxnet.symbol.square"><code class="xref py py-obj docutils literal"><span class="pre">square</span></code></a></td>
<td>Returns element-wise squared value of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="logic-functions">
<span id="logic-functions"></span><h3>Logic functions<a class="headerlink" href="#logic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_equal" title="mxnet.symbol.broadcast_equal"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_not_equal" title="mxnet.symbol.broadcast_not_equal"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_not_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_greater" title="mxnet.symbol.broadcast_greater"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_greater</span></code></a></td>
<td>Returns the result of element-wise <strong>greater than</strong> (>) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_greater_equal" title="mxnet.symbol.broadcast_greater_equal"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_greater_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>greater than or equal to</strong> (>=) comparison operation with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_lesser" title="mxnet.symbol.broadcast_lesser"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_lesser</span></code></a></td>
<td>Returns the result of element-wise <strong>lesser than</strong> (<) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_lesser_equal" title="mxnet.symbol.broadcast_lesser_equal"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_lesser_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>lesser than or equal to</strong> (<=) comparison operation with broadcasting.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="random-sampling">
<span id="random-sampling"></span><h3>Random sampling<a class="headerlink" href="#random-sampling" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.random_uniform" title="mxnet.symbol.random_uniform"><code class="xref py py-obj docutils literal"><span class="pre">random_uniform</span></code></a></td>
<td>Draw random samples from a uniform distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.random_normal" title="mxnet.symbol.random_normal"><code class="xref py py-obj docutils literal"><span class="pre">random_normal</span></code></a></td>
<td>Draw random samples from a normal (Gaussian) distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.random_gamma" title="mxnet.symbol.random_gamma"><code class="xref py py-obj docutils literal"><span class="pre">random_gamma</span></code></a></td>
<td>Draw random samples from a gamma distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.random_exponential" title="mxnet.symbol.random_exponential"><code class="xref py py-obj docutils literal"><span class="pre">random_exponential</span></code></a></td>
<td>Draw random samples from an exponential distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.random_poisson" title="mxnet.symbol.random_poisson"><code class="xref py py-obj docutils literal"><span class="pre">random_poisson</span></code></a></td>
<td>Draw random samples from a Poisson distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.random_negative_binomial" title="mxnet.symbol.random_negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">random_negative_binomial</span></code></a></td>
<td>Draw random samples from a negative binomial distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.random_generalized_negative_binomial" title="mxnet.symbol.random_generalized_negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">random_generalized_negative_binomial</span></code></a></td>
<td>Draw random samples from a generalized negative binomial distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.sample_uniform" title="mxnet.symbol.sample_uniform"><code class="xref py py-obj docutils literal"><span class="pre">sample_uniform</span></code></a></td>
<td>Concurrent sampling from multiple uniform distributions on the intervals given by <em>[low,high)</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sample_normal" title="mxnet.symbol.sample_normal"><code class="xref py py-obj docutils literal"><span class="pre">sample_normal</span></code></a></td>
<td>Concurrent sampling from multiple normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.sample_gamma" title="mxnet.symbol.sample_gamma"><code class="xref py py-obj docutils literal"><span class="pre">sample_gamma</span></code></a></td>
<td>Concurrent sampling from multiple gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sample_exponential" title="mxnet.symbol.sample_exponential"><code class="xref py py-obj docutils literal"><span class="pre">sample_exponential</span></code></a></td>
<td>Concurrent sampling from multiple exponential distributions with parameters lambda (rate).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.sample_poisson" title="mxnet.symbol.sample_poisson"><code class="xref py py-obj docutils literal"><span class="pre">sample_poisson</span></code></a></td>
<td>Concurrent sampling from multiple Poisson distributions with parameters lambda (rate).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sample_negative_binomial" title="mxnet.symbol.sample_negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">sample_negative_binomial</span></code></a></td>
<td>Concurrent sampling from multiple negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.sample_generalized_negative_binomial" title="mxnet.symbol.sample_generalized_negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">sample_generalized_negative_binomial</span></code></a></td>
<td>Concurrent sampling from multiple generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="ndarray.html#mxnet.random.seed" title="mxnet.random.seed"><code class="xref py py-obj docutils literal"><span class="pre">mxnet.random.seed</span></code></a></td>
<td>Seeds the random number generators in MXNet.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sorting-and-searching">
<span id="sorting-and-searching"></span><h3>Sorting and searching<a class="headerlink" href="#sorting-and-searching" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sort" title="mxnet.symbol.sort"><code class="xref py py-obj docutils literal"><span class="pre">sort</span></code></a></td>
<td>Returns a sorted copy of an input array along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.topk" title="mxnet.symbol.topk"><code class="xref py py-obj docutils literal"><span class="pre">topk</span></code></a></td>
<td>Returns the top <em>k</em> elements in an input array along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.argsort" title="mxnet.symbol.argsort"><code class="xref py py-obj docutils literal"><span class="pre">argsort</span></code></a></td>
<td>Returns the indices that would sort an input array along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.argmax" title="mxnet.symbol.argmax"><code class="xref py py-obj docutils literal"><span class="pre">argmax</span></code></a></td>
<td>Returns indices of the maximum values along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.argmin" title="mxnet.symbol.argmin"><code class="xref py py-obj docutils literal"><span class="pre">argmin</span></code></a></td>
<td>Returns indices of the minimum values along an axis.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linear-algebra">
<span id="linear-algebra"></span><h3>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.linalg_gemm" title="mxnet.symbol.linalg_gemm"><code class="xref py py-obj docutils literal"><span class="pre">linalg_gemm</span></code></a></td>
<td>Performs general matrix multiplication and accumulation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.linalg_gemm2" title="mxnet.symbol.linalg_gemm2"><code class="xref py py-obj docutils literal"><span class="pre">linalg_gemm2</span></code></a></td>
<td>Performs general matrix multiplication.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.linalg_potrf" title="mxnet.symbol.linalg_potrf"><code class="xref py py-obj docutils literal"><span class="pre">linalg_potrf</span></code></a></td>
<td>Performs Cholesky factorization of a symmetric positive-definite matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.linalg_potri" title="mxnet.symbol.linalg_potri"><code class="xref py py-obj docutils literal"><span class="pre">linalg_potri</span></code></a></td>
<td>Performs matrix inversion from a Cholesky factorization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.linalg_trmm" title="mxnet.symbol.linalg_trmm"><code class="xref py py-obj docutils literal"><span class="pre">linalg_trmm</span></code></a></td>
<td>Performs multiplication with a triangular matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.linalg_trsm" title="mxnet.symbol.linalg_trsm"><code class="xref py py-obj docutils literal"><span class="pre">linalg_trsm</span></code></a></td>
<td>Solves matrix equations involving a triangular matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.linalg_sumlogdiag" title="mxnet.symbol.linalg_sumlogdiag"><code class="xref py py-obj docutils literal"><span class="pre">linalg_sumlogdiag</span></code></a></td>
<td>Computes the sum of the logarithms of all diagonal elements in a matrix.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="miscellaneous">
<span id="miscellaneous"></span><h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.maximum" title="mxnet.symbol.maximum"><code class="xref py py-obj docutils literal"><span class="pre">maximum</span></code></a></td>
<td>Returns element-wise maximum of the input elements.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.minimum" title="mxnet.symbol.minimum"><code class="xref py py-obj docutils literal"><span class="pre">minimum</span></code></a></td>
<td>Returns element-wise minimum of the input elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.broadcast_maximum" title="mxnet.symbol.broadcast_maximum"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_maximum</span></code></a></td>
<td>Returns element-wise maximum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.broadcast_minimum" title="mxnet.symbol.broadcast_minimum"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_minimum</span></code></a></td>
<td>Returns element-wise minimum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.clip" title="mxnet.symbol.clip"><code class="xref py py-obj docutils literal"><span class="pre">clip</span></code></a></td>
<td>Clips (limits) the values in an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.abs" title="mxnet.symbol.abs"><code class="xref py py-obj docutils literal"><span class="pre">abs</span></code></a></td>
<td>Returns element-wise absolute value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.sign" title="mxnet.symbol.sign"><code class="xref py py-obj docutils literal"><span class="pre">sign</span></code></a></td>
<td>Returns element-wise sign of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.gamma" title="mxnet.symbol.gamma"><code class="xref py py-obj docutils literal"><span class="pre">gamma</span></code></a></td>
<td>Returns the gamma function (extension of the factorial function to the reals) , computed element-wise on the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.gammaln" title="mxnet.symbol.gammaln"><code class="xref py py-obj docutils literal"><span class="pre">gammaln</span></code></a></td>
<td>Returns element-wise log of the absolute value of the gamma function of the input.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="neural-network">
<span id="neural-network"></span><h2>Neural network<a class="headerlink" href="#neural-network" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic">
<span id="basic"></span><h3>Basic<a class="headerlink" href="#basic" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.FullyConnected" title="mxnet.symbol.FullyConnected"><code class="xref py py-obj docutils literal"><span class="pre">FullyConnected</span></code></a></td>
<td>Applies a linear transformation: <span class="math">\(Y = XW^T + b\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Convolution" title="mxnet.symbol.Convolution"><code class="xref py py-obj docutils literal"><span class="pre">Convolution</span></code></a></td>
<td>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Activation" title="mxnet.symbol.Activation"><code class="xref py py-obj docutils literal"><span class="pre">Activation</span></code></a></td>
<td>Applies an activation function element-wise to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.BatchNorm" title="mxnet.symbol.BatchNorm"><code class="xref py py-obj docutils literal"><span class="pre">BatchNorm</span></code></a></td>
<td>Batch normalization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Pooling" title="mxnet.symbol.Pooling"><code class="xref py py-obj docutils literal"><span class="pre">Pooling</span></code></a></td>
<td>Performs pooling on the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.SoftmaxOutput" title="mxnet.symbol.SoftmaxOutput"><code class="xref py py-obj docutils literal"><span class="pre">SoftmaxOutput</span></code></a></td>
<td>Computes the gradient of cross entropy loss with respect to softmax output.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.softmax" title="mxnet.symbol.softmax"><code class="xref py py-obj docutils literal"><span class="pre">softmax</span></code></a></td>
<td>Applies the softmax function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.log_softmax" title="mxnet.symbol.log_softmax"><code class="xref py py-obj docutils literal"><span class="pre">log_softmax</span></code></a></td>
<td>Computes the log softmax of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="more">
<span id="more"></span><h3>More<a class="headerlink" href="#more" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Correlation" title="mxnet.symbol.Correlation"><code class="xref py py-obj docutils literal"><span class="pre">Correlation</span></code></a></td>
<td>Applies correlation to inputs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Deconvolution" title="mxnet.symbol.Deconvolution"><code class="xref py py-obj docutils literal"><span class="pre">Deconvolution</span></code></a></td>
<td>Computes 2D transposed convolution (aka fractionally strided convolution) of the input tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.RNN" title="mxnet.symbol.RNN"><code class="xref py py-obj docutils literal"><span class="pre">RNN</span></code></a></td>
<td>Applies a recurrent layer to input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.Embedding" title="mxnet.symbol.Embedding"><code class="xref py py-obj docutils literal"><span class="pre">Embedding</span></code></a></td>
<td>Maps integer indices to vector representations (embeddings).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.LeakyReLU" title="mxnet.symbol.LeakyReLU"><code class="xref py py-obj docutils literal"><span class="pre">LeakyReLU</span></code></a></td>
<td>Applies Leaky rectified linear unit activation element-wise to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.InstanceNorm" title="mxnet.symbol.InstanceNorm"><code class="xref py py-obj docutils literal"><span class="pre">InstanceNorm</span></code></a></td>
<td>Applies instance normalization to the n-dimensional input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.L2Normalization" title="mxnet.symbol.L2Normalization"><code class="xref py py-obj docutils literal"><span class="pre">L2Normalization</span></code></a></td>
<td>Normalize the input array using the L2 norm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.LRN" title="mxnet.symbol.LRN"><code class="xref py py-obj docutils literal"><span class="pre">LRN</span></code></a></td>
<td>Applies local response normalization to the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.ROIPooling" title="mxnet.symbol.ROIPooling"><code class="xref py py-obj docutils literal"><span class="pre">ROIPooling</span></code></a></td>
<td>Performs region of interest(ROI) pooling on the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.SoftmaxActivation" title="mxnet.symbol.SoftmaxActivation"><code class="xref py py-obj docutils literal"><span class="pre">SoftmaxActivation</span></code></a></td>
<td>Applies softmax activation to input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Dropout" title="mxnet.symbol.Dropout"><code class="xref py py-obj docutils literal"><span class="pre">Dropout</span></code></a></td>
<td>Applies dropout operation to input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.BilinearSampler" title="mxnet.symbol.BilinearSampler"><code class="xref py py-obj docutils literal"><span class="pre">BilinearSampler</span></code></a></td>
<td>Applies bilinear sampling to input feature map, which is the key of “[NIPS2015] Spatial Transformer Networks”     output[batch, channel, y_dst, x_dst] = G(data[batch, channel, y_src, x_src)     x_dst, y_dst enumerate all spatial locations in output     x_src = grid[batch, 0, y_dst, x_dst]     y_src = grid[batch, 1, y_dst, x_dst]     G() denotes the bilinear interpolation kernel The out-boundary points will be padded as zeros.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.GridGenerator" title="mxnet.symbol.GridGenerator"><code class="xref py py-obj docutils literal"><span class="pre">GridGenerator</span></code></a></td>
<td>Generates 2D sampling grid for bilinear sampling.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.UpSampling" title="mxnet.symbol.UpSampling"><code class="xref py py-obj docutils literal"><span class="pre">UpSampling</span></code></a></td>
<td>Performs nearest neighbor/bilinear up sampling to inputs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.SpatialTransformer" title="mxnet.symbol.SpatialTransformer"><code class="xref py py-obj docutils literal"><span class="pre">SpatialTransformer</span></code></a></td>
<td>Applies a spatial transformer to input feature map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.LinearRegressionOutput" title="mxnet.symbol.LinearRegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">LinearRegressionOutput</span></code></a></td>
<td>Computes and optimizes for squared loss during backward propagation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.LogisticRegressionOutput" title="mxnet.symbol.LogisticRegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">LogisticRegressionOutput</span></code></a></td>
<td>Applies a logistic function to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.MAERegressionOutput" title="mxnet.symbol.MAERegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">MAERegressionOutput</span></code></a></td>
<td>Computes mean absolute error of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.SVMOutput" title="mxnet.symbol.SVMOutput"><code class="xref py py-obj docutils literal"><span class="pre">SVMOutput</span></code></a></td>
<td>Computes support vector machine based transformation of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.softmax_cross_entropy" title="mxnet.symbol.softmax_cross_entropy"><code class="xref py py-obj docutils literal"><span class="pre">softmax_cross_entropy</span></code></a></td>
<td>Calculate cross entropy of softmax output and one-hot label.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.smooth_l1" title="mxnet.symbol.smooth_l1"><code class="xref py py-obj docutils literal"><span class="pre">smooth_l1</span></code></a></td>
<td>Calculate Smooth L1 Loss(lhs, scalar) by summing</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.IdentityAttachKLSparseReg" title="mxnet.symbol.IdentityAttachKLSparseReg"><code class="xref py py-obj docutils literal"><span class="pre">IdentityAttachKLSparseReg</span></code></a></td>
<td>Apply a sparse regularization to the output a sigmoid activation function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.MakeLoss" title="mxnet.symbol.MakeLoss"><code class="xref py py-obj docutils literal"><span class="pre">MakeLoss</span></code></a></td>
<td>Make your own loss function in network construction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.symbol.BlockGrad" title="mxnet.symbol.BlockGrad"><code class="xref py py-obj docutils literal"><span class="pre">BlockGrad</span></code></a></td>
<td>Stops gradient computation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.symbol.Custom" title="mxnet.symbol.Custom"><code class="xref py py-obj docutils literal"><span class="pre">Custom</span></code></a></td>
<td>Apply a custom operator implemented in a frontend language (like Python).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="api-reference">
<span id="api-reference"></span><h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<script src="../../_static/js/auto_module_index.js" type="text/javascript"></script><span class="target" id="module-mxnet.symbol"></span><p>Symbolic configuration API of MXNet.</p>
<dl class="class">
<dt id="mxnet.symbol.Symbol">
<em class="property">class </em><code class="descclassname">mxnet.symbol.</code><code class="descname">Symbol</code><span class="sig-paren">(</span><em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbol is symbolic graph of the mxnet.</p>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a string representation of the symbol.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generator object of symbol.</p>
<p>One can loop through the returned object list to get outputs.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="gp">>>> </span><span class="n">d</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'d'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">c</span>
<span class="gp">>>> </span><span class="n">out</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">out</span>
<span class="go"><Symbol Grouped></span>
<span class="gp">>>> </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">i</span>
<span class="gp">...</span>
<span class="go"><Symbol d></span>
<span class="go"><Symbol _plus0></span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__add__(y) <=> x+y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_add</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__sub__(y) <=> x-y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_sub</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__rsub__">
<code class="descname">__rsub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rsub__(y) <=> y-x</p>
<p>Only <cite>NDArray</cite> is supported for now.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">3</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="fm">__rsub__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-2., -2., -2.],</span>
<span class="go">       [-2., -2., -2.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__mul__">
<code class="descname">__mul__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__mul__(y) <=> x*y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_mul</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__div__">
<code class="descname">__div__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__div__(y) <=> x/y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_div</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__rdiv__">
<code class="descname">__rdiv__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rdiv__(y) <=> y/x</p>
<p>Only <cite>NDArray</cite> is supported for now.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">3</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="fm">__rdiv__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.33333334,  0.33333334,  0.33333334],</span>
<span class="go">       [ 0.33333334,  0.33333334,  0.33333334]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__mod__">
<code class="descname">__mod__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__mod__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__mod__(y) <=> x%y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_mod</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__rmod__">
<code class="descname">__rmod__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__rmod__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rmod__(y) <=> y%x</p>
<p>Only <cite>NDArray</cite> is supported for now.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">3</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="fm">__rmod__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.,</span>
<span class="go">       [ 1.,  1.,  1., dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__pow__">
<code class="descname">__pow__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__pow__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__pow__(y) <=> x**y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_pow</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__neg__">
<code class="descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__neg__() <=> -x</p>
<p>Numerical negative, element-wise.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">a</span>
<span class="go"><Symbol a></span>
<span class="gp">>>> </span><span class="o">-</span><span class="n">a</span>
<span class="go"><Symbol _mulscalar0></span>
<span class="gp">>>> </span><span class="n">a_neg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">b</span>
<span class="gp">>>> </span><span class="n">ex</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">a</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">b</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">>>> </span><span class="n">ex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-1., -1., -1.],</span>
<span class="go">       [-1., -1., -1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__deepcopy__">
<code class="descname">__deepcopy__</code><span class="sig-paren">(</span><em>_</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the input object.</p>
<p>This function returns a deep copy of the input object including the current state
of all its parameters such as weights, biases, etc.</p>
<p>Any changes made to the deep copy do not reflect in the original object.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="kn">import</span> <span class="nn">copy</span>
<span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">data_1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">data</span>
<span class="gp">>>> </span><span class="n">data_1</span><span class="o">.</span><span class="n">tojson</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">data_1</span> <span class="ow">is</span> <span class="n">data</span>    <span class="c1"># Data got modified</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__eq__(y) <=> x==y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_equal</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ne__(y) <=> x!=y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_not_equal</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__gt__">
<code class="descname">__gt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__gt__(y) <=> x>y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_greater</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__ge__">
<code class="descname">__ge__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ge__(y) <=> x>=y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_greater_equal</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__lt__">
<code class="descname">__lt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__lt__(y) <=> x<y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_lesser</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__le__">
<code class="descname">__le__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__le__(y) <=> x<=y</p>
<p>Scalar input is supported.
Broadcasting is not supported. Use <cite>broadcast_lesser_equal</cite> instead.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Composes symbol using inputs.</p>
<p>x.__call__(y, z) <=> x(y,z)</p>
<p>This function internally calls <cite>_compose</cite> to compose the symbol and
returns the composed symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">net1</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc1'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">net2</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'fc3'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">composed</span> <span class="o">=</span> <span class="n">net2</span><span class="p">(</span><span class="n">fc3_data</span><span class="o">=</span><span class="n">net1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'composed'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">composed</span>
<span class="go"><Symbol composed></span>
<span class="gp">>>> </span><span class="n">called</span> <span class="o">=</span> <span class="n">net2</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">fc3_data</span><span class="o">=</span><span class="n">net1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'composed'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">called</span>
<span class="go"><Symbol composed></span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> – Positional arguments.</li>
<li><strong>kwargs</strong> – Keyword arguments.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The resulting symbol.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getitem__(i) <=> x[i]</p>
<p>Returns a sliced view of the input symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">a</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go"><Symbol a></span>
<span class="gp">>>> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go"><Symbol a></span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>int or str</em>) – Indexing key</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.symbol.Symbol.name">
<code class="descname">name</code><a class="headerlink" href="#mxnet.symbol.Symbol.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets name string from the symbol, this function only works for non-grouped symbol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>value</strong> –
The name of this symbol, returns <code class="docutils literal"><span class="pre">None</span></code> for grouped symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.attr">
<code class="descname">attr</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the attribute string for corresponding input key from the symbol.</p>
<p>This function only works for non-grouped symbols.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'mood'</span><span class="p">:</span> <span class="s1">'angry'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">data</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s1">'mood'</span><span class="p">)</span>
<span class="go">'angry'</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>str</em>) – The key corresponding to the desired attribute.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>value</strong> –
The desired attribute value, returns <code class="docutils literal"><span class="pre">None</span></code> if the attribute does not exist.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.list_attr">
<code class="descname">list_attr</code><span class="sig-paren">(</span><em>recursive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.list_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all attributes from the symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'mood'</span><span class="p">:</span> <span class="s1">'angry'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">data</span><span class="o">.</span><span class="n">list_attr</span><span class="p">()</span>
<span class="go">{'mood': 'angry'}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret</strong> –
A dictionary mapping attribute keys to values.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Dict of str to str</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.attr_dict">
<code class="descname">attr_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.attr_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively gets all attributes from the symbol and its children.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'a1'</span><span class="p">:</span><span class="s1">'a2'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'b1'</span><span class="p">:</span><span class="s1">'b2'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="gp">>>> </span><span class="n">c</span><span class="o">.</span><span class="n">attr_dict</span><span class="p">()</span>
<span class="go">{'a': {'a1': 'a2'}, 'b': {'b1': 'b2'}}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret</strong> –
There is a key in the returned dict for every child with non-empty attribute set.
For each symbol, the name of the symbol is its key in the dict
and the correspond value is that symbol’s attribute list (itself a dictionary).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Dict of str to dict</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.get_internals">
<code class="descname">get_internals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.get_internals" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a new grouped symbol <cite>sgroup</cite>. The output of <cite>sgroup</cite> is a list of
outputs of all of the internal nodes.</p>
<p>Consider the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_internals</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">d</span>
<span class="go"><Symbol Grouped></span>
<span class="gp">>>> </span><span class="n">d</span><span class="o">.</span><span class="n">list_outputs</span><span class="p">()</span>
<span class="go">['a', 'b', '_plus4_output']</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>sgroup</strong> –
A symbol group containing all internal and leaf nodes of the computation graph
used to compute the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.get_children">
<code class="descname">get_children</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.get_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a new grouped symbol whose output contains
inputs to output nodes of the original symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'z'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">z</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">a</span>
<span class="gp">>>> </span><span class="n">b</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span>
<span class="go"><Symbol Grouped></span>
<span class="gp">>>> </span><span class="n">b</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span><span class="o">.</span><span class="n">list_outputs</span><span class="p">()</span>
<span class="go">['x', '_plus10_output']</span>
<span class="gp">>>> </span><span class="n">b</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span><span class="o">.</span><span class="n">list_outputs</span><span class="p">()</span>
<span class="go">['y', 'z']</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>sgroup</strong> –
The children of the head node. If the symbol has no
inputs then <code class="docutils literal"><span class="pre">None</span></code> will be returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Symbol or None</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.list_arguments">
<code class="descname">list_arguments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.list_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all the arguments in the symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">c</span><span class="o">.</span><span class="n">list_arguments</span>
<span class="go">['a', 'b']</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>args</strong> –
List containing the names of all the arguments required to compute the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of string</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.list_outputs">
<code class="descname">list_outputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.list_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all the outputs in the symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">c</span><span class="o">.</span><span class="n">list_outputs</span><span class="p">()</span>
<span class="go">['_plus12_output']</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of all the outputs.
For most symbols, this list contains only the name of this symbol.
For symbol groups, this is a list with the names of all symbols
in the group.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.list_auxiliary_states">
<code class="descname">list_auxiliary_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.list_auxiliary_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all the auxiliary states in the symbol.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">c</span><span class="o">.</span><span class="n">list_auxiliary_states</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Example of auxiliary states in <cite>BatchNorm</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">weight</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'fc1_weight'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">fc1</span>  <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc1'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">fc2</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(</span><span class="n">fc1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'batchnorm0'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">fc2</span><span class="o">.</span><span class="n">list_auxiliary_states</span><span class="p">()</span>
<span class="go">['batchnorm0_moving_mean', 'batchnorm0_moving_var']</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>aux_states</strong> –
List of the auxiliary states in input symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Auxiliary states are special states of symbols that do not correspond to an argument,
and are not updated by gradient descent. Common examples of auxiliary states
include the <cite>moving_mean</cite> and <cite>moving_variance</cite> in <cite>BatchNorm</cite>.
Most operators do not have auxiliary states.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.list_inputs">
<code class="descname">list_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.list_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all arguments and auxiliary states of this Symbol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>inputs</strong> –
List of all inputs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">bn</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">BatchNorm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'bn'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">bn</span><span class="o">.</span><span class="n">list_arguments</span><span class="p">()</span>
<span class="go">['bn_data', 'bn_gamma', 'bn_beta']</span>
<span class="gp">>>> </span><span class="n">bn</span><span class="o">.</span><span class="n">list_auxiliary_states</span><span class="p">()</span>
<span class="go">['bn_moving_mean', 'bn_moving_var']</span>
<span class="gp">>>> </span><span class="n">bn</span><span class="o">.</span><span class="n">list_inputs</span><span class="p">()</span>
<span class="go">['bn_data', 'bn_gamma', 'bn_beta', 'bn_moving_mean', 'bn_moving_var']</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.infer_type">
<code class="descname">infer_type</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.infer_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers the type of all arguments and all outputs, given the known types
for some arguments.</p>
<p>This function takes the known types of some arguments in either positional way
or keyword argument way as input. It returns a tuple of <cite>None</cite> values
if there is not enough information to deduce the missing types.</p>
<p>Inconsistencies in the known types will cause an error to be raised.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">arg_types</span><span class="p">,</span> <span class="n">out_types</span><span class="p">,</span> <span class="n">aux_types</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">infer_type</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">arg_types</span>
<span class="go">[<type 'numpy.float32'>, <type 'numpy.float32'>]</span>
<span class="gp">>>> </span><span class="n">out_types</span>
<span class="go">[<type 'numpy.float32'>]</span>
<span class="gp">>>> </span><span class="n">aux_types</span>
<span class="go">[]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*args</strong> – <p>Type of known arguments in a positional way.
Unknown type can be marked as None.</p>
</li>
<li><strong>**kwargs</strong> – <p>Keyword arguments of known types.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>arg_types</strong> (<em>list of numpy.dtype or None</em>) –
List of argument types.
The order is same as the order of list_arguments().</li>
<li><strong>out_types</strong> (<em>list of numpy.dtype or None</em>) –
List of output types.
The order is same as the order of list_outputs().</li>
<li><strong>aux_types</strong> (<em>list of numpy.dtype or None</em>) –
List of auxiliary state types.
The order is same as the order of list_auxiliary_states().</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.infer_shape">
<code class="descname">infer_shape</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.infer_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers the shapes of all arguments and all outputs given the known shapes of
some arguments.</p>
<p>This function takes the known shapes of some arguments in either positional way
or keyword argument way as input. It returns a tuple of <cite>None</cite> values
if there is not enough information to deduce the missing shapes.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">arg_shapes</span><span class="p">,</span> <span class="n">out_shapes</span><span class="p">,</span> <span class="n">aux_shapes</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">infer_shape</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">arg_shapes</span>
<span class="go">[(3L, 3L), (3L, 3L)]</span>
<span class="gp">>>> </span><span class="n">out_shapes</span>
<span class="go">[(3L, 3L)]</span>
<span class="gp">>>> </span><span class="n">aux_shapes</span>
<span class="go">[]</span>
<span class="gp">>>> </span><span class="n">c</span><span class="o">.</span><span class="n">infer_shape</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 0s in shape means unknown dimensions. So, returns None.</span>
<span class="go">(None, None, None)</span>
</pre></div>
</div>
<p>Inconsistencies in the known shapes will cause an error to be raised.
See the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc1'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc2'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">weight_shape</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span><span class="o">.</span><span class="n">infer_shape</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">fc1_weight</span><span class="o">=</span><span class="n">weight_shape</span><span class="p">)</span>
<span class="go">Error in operator fc1: Shape inconsistent, Provided=(1,100), inferred shape=(1000,100)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*args</strong> – <p>Shape of arguments in a positional way.
Unknown shape can be marked as None.</p>
</li>
<li><strong>**kwargs</strong> – <p>Keyword arguments of the known shapes.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>arg_shapes</strong> (<em>list of tuple or None</em>) –
List of argument shapes.
The order is same as the order of list_arguments().</li>
<li><strong>out_shapes</strong> (<em>list of tuple or None</em>) –
List of output shapes.
The order is same as the order of list_outputs().</li>
<li><strong>aux_shapes</strong> (<em>list of tuple or None</em>) –
List of auxiliary state shapes.
The order is same as the order of list_auxiliary_states().</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.infer_shape_partial">
<code class="descname">infer_shape_partial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.infer_shape_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers the shape partially.</p>
<p>This functions works the same way as <cite>infer_shape</cite>,
except that this function can return partial results.</p>
<p>In the following example, information about fc2 is not available. So, <cite>infer_shape</cite>
will return a tuple of <cite>None</cite> values but <cite>infer_shape_partial</cite> will return partial values.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">prev</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'prev'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">fc1</span>  <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc1'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">fc2</span>  <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">prev</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'fc2'</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span>  <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">elemwise_add</span><span class="p">(</span><span class="n">fc1</span><span class="p">,</span> <span class="n">fc2</span><span class="p">),</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span><span class="o">.</span><span class="n">list_arguments</span><span class="p">()</span>
<span class="go">['data', 'fc1_weight', 'fc1_bias', 'prev', 'fc2_weight', 'fc2_bias']</span>
<span class="gp">>>> </span><span class="n">out</span><span class="o">.</span><span class="n">infer_shape</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">64</span><span class="p">))</span>
<span class="go">(None, None, None)</span>
<span class="gp">>>> </span><span class="n">out</span><span class="o">.</span><span class="n">infer_shape_partial</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">64</span><span class="p">))</span>
<span class="go">([(10L, 64L), (128L, 64L), (128L,), (), (), ()], [(10L, 128L)], [])</span>
<span class="gp">>>> </span><span class="c1"># infers shape if you give information about fc2</span>
<span class="gp">>>> </span><span class="n">out</span><span class="o">.</span><span class="n">infer_shape</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">64</span><span class="p">),</span> <span class="n">prev</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">128</span><span class="p">))</span>
<span class="go">([(10L, 64L), (128L, 64L), (128L,), (10L, 128L), (128L, 128L), (128L,)], [(10L, 128L)], [])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*args</strong> – <p>Shape of arguments in a positional way.
Unknown shape can be marked as None</p>
</li>
<li><strong>**kwargs</strong> – <p>Keyword arguments of known shapes.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>arg_shapes</strong> (<em>list of tuple or None</em>) –
List of argument shapes.
The order is same as the order of list_arguments().</li>
<li><strong>out_shapes</strong> (<em>list of tuple or None</em>) –
List of output shapes.
The order is same as the order of list_outputs().</li>
<li><strong>aux_shapes</strong> (<em>list of tuple or None</em>) –
List of auxiliary state shapes.
The order is same as the order of list_auxiliary_states().</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.debug_str">
<code class="descname">debug_str</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.debug_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a debug string of symbol.</p>
<p>It contains Symbol output, variables and operators in the computation graph
with their inputs, variables and attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Debug string of the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">d</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">d</span><span class="o">.</span><span class="n">debug_str</span><span class="p">()</span>
<span class="gp">>>> </span><span class="k">print</span> <span class="n">d</span><span class="o">.</span><span class="n">debug_str</span><span class="p">()</span>
<span class="go">Symbol Outputs:</span>
<span class="go">        output[0]=fullyconnected0(0)</span>
<span class="go">Variable:a</span>
<span class="go">--------------------</span>
<span class="go">Op:_mul_scalar, Name=_mulscalar0</span>
<span class="go">Inputs:</span>
<span class="go">        arg[0]=a(0) version=0</span>
<span class="go">Attrs:</span>
<span class="go">        scalar=2</span>
<span class="go">--------------------</span>
<span class="go">Op:sin, Name=sin0</span>
<span class="go">Inputs:</span>
<span class="go">        arg[0]=a(0) version=0</span>
<span class="go">--------------------</span>
<span class="go">Op:elemwise_add, Name=_plus0</span>
<span class="go">Inputs:</span>
<span class="go">        arg[0]=_mulscalar0(0)</span>
<span class="go">        arg[1]=sin0(0)</span>
<span class="go">Variable:fullyconnected0_weight</span>
<span class="go">Variable:fullyconnected0_bias</span>
<span class="go">--------------------</span>
<span class="go">Op:FullyConnected, Name=fullyconnected0</span>
<span class="go">Inputs:</span>
<span class="go">        arg[0]=_plus0(0)</span>
<span class="go">        arg[1]=fullyconnected0_weight(0) version=0</span>
<span class="go">        arg[2]=fullyconnected0_bias(0) version=0</span>
<span class="go">Attrs:</span>
<span class="go">        num_hidden=10</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves symbol to a file.</p>
<p>You can also use pickle to do the job if you only work on python.
The advantage of <cite>load</cite>/<cite>save</cite> functions is that the file contents are language agnostic.
This means the model saved by one language binding can be loaded by a different
language binding of <cite>MXNet</cite>.
You also get the benefit of being able to directly load/save from cloud storage(S3, HDFS).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) – <p>The name of the file.</p>
<ul class="simple">
<li>“s3://my-bucket/path/my-s3-symbol”</li>
<li>“hdfs://my-bucket/path/my-hdfs-symbol”</li>
<li>“/path-to/my-local-symbol”</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-meth docutils literal"><span class="pre">symbol.load()</span></code></dt>
<dd>Used to load symbol from file.</dd>
</dl>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.tojson">
<code class="descname">tojson</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.tojson" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves symbol to a JSON string.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-meth docutils literal"><span class="pre">symbol.load_json()</span></code></dt>
<dd>Used to load symbol from JSON string.</dd>
</dl>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.simple_bind">
<code class="descname">simple_bind</code><span class="sig-paren">(</span><em>ctx</em>, <em>grad_req='write'</em>, <em>type_dict=None</em>, <em>group2ctx=None</em>, <em>shared_arg_names=None</em>, <em>shared_exec=None</em>, <em>shared_buffer=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.simple_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind current symbol to get an executor, allocate all the arguments needed.
Allows specifying data types.</p>
<p>This function simplifies the binding procedure. You need to specify only input data shapes.
Before binding the executor, the function allocates arguments and auxiliary states
that were not explicitly specified. Allows specifying data types.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">FullyConnected</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">exe</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">simple_bind</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">grad_req</span><span class="o">=</span><span class="s1">'null'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">exe</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="go">[<NDArray 5x4 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">exe</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">exe</span><span class="o">.</span><span class="n">arg_arrays</span>
<span class="go">[<NDArray 5x4 @cpu(0)>, <NDArray 4x4 @cpu(0)>, <NDArray 4 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">exe</span><span class="o">.</span><span class="n">grad_arrays</span>
<span class="go">[<NDArray 5x4 @cpu(0)>, <NDArray 4x4 @cpu(0)>, <NDArray 4 @cpu(0)>]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ctx</strong> (<em>Context</em>) – The device context the generated executor to run on.</li>
<li><strong>grad_req</strong> (<em>string</em>) – <p>{‘write’, ‘add’, ‘null’}, or list of str or dict of str to str, optional
To specify how we should update the gradient to the <cite>args_grad</cite>.</p>
<ul>
<li>‘write’ means every time gradient is written to specified <cite>args_grad</cite> NDArray.</li>
<li>‘add’ means every time gradient is added to the specified NDArray.</li>
<li>‘null’ means no action is taken, the gradient may not be calculated.</li>
</ul>
</li>
<li><strong>type_dict</strong> (<em>Dict of str->numpy.dtype</em>) – Input type dictionary, name->dtype</li>
<li><strong>group2ctx</strong> (<em>Dict of string to mx.Context</em>) – The dict mapping the <cite>ctx_group</cite> attribute to the context assignment.</li>
<li><strong>shared_arg_names</strong> (<em>List of string</em>) – The argument names whose <cite>NDArray</cite> of shared_exec can be reused for initializing
the current executor.</li>
<li><strong>shared_exec</strong> (<em>Executor</em>) – The executor whose arg_arrays, arg_arrays, grad_arrays, and aux_arrays can be
reused for initializing the current executor.</li>
<li><strong>shared_buffer</strong> (Dict of string to <cite>NDArray</cite>) – The dict mapping argument names to the <cite>NDArray</cite> that can be reused for initializing
the current executor. This buffer will be checked for reuse if one argument name
of the current executor is not found in <cite>shared_arg_names</cite>.</li>
<li><strong>kwargs</strong> (<em>Dict of str->shape</em>) – Input shape dictionary, name->shape</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>executor</strong> –
The generated executor</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">mxnet.Executor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.bind">
<code class="descname">bind</code><span class="sig-paren">(</span><em>ctx</em>, <em>args</em>, <em>args_grad=None</em>, <em>grad_req='write'</em>, <em>aux_states=None</em>, <em>group2ctx=None</em>, <em>shared_exec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Binds the current symbol to an executor and returns it.</p>
<p>We first declare the computation and then bind to the data to run.
This function returns an executor which provides method <cite>forward()</cite> method for evaluation
and a <cite>outputs()</cite> method to get all the results.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go"><Symbol _plus1></span>
<span class="gp">>>> </span><span class="n">ex</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">'a'</span> <span class="p">:</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="s1">'b'</span> <span class="p">:</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])})</span>
<span class="gp">>>> </span><span class="n">ex</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="go">[<NDArray 2x3 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">ex</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">[[ 2.  2.  2.]</span>
<span class="go">[ 2.  2.  2.]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ctx</strong> (<em>Context</em>) – The device context the generated executor to run on.</li>
<li><strong>args</strong> (<em>list of NDArray or dict of str to NDArray</em>) – <p>Input arguments to the symbol.</p>
<ul>
<li>If the input type is a list of <cite>NDArray</cite>, the order should be same as the order
of <cite>list_arguments()</cite>.</li>
<li>If the input type is a dict of str to <cite>NDArray</cite>, then it maps the name of arguments
to the corresponding <cite>NDArray</cite>.</li>
<li>In either case, all the arguments must be provided.</li>
</ul>
</li>
<li><strong>args_grad</strong> (list of NDArray or dict of str to <cite>NDArray</cite>, optional) – <p>When specified, <cite>args_grad</cite> provides NDArrays to hold
the result of gradient value in backward.</p>
<ul>
<li>If the input type is a list of <cite>NDArray</cite>, the order should be same as the order
of <cite>list_arguments()</cite>.</li>
<li>If the input type is a dict of str to <cite>NDArray</cite>, then it maps the name of arguments
to the corresponding NDArray.</li>
<li>When the type is a dict of str to <cite>NDArray</cite>, one only need to provide the dict
for required argument gradient.
Only the specified argument gradient will be calculated.</li>
</ul>
</li>
<li><strong>grad_req</strong> (<em>{'write', 'add', 'null'}, or list of str or dict of str to str, optional</em>) – <p>To specify how we should update the gradient to the <cite>args_grad</cite>.</p>
<ul>
<li>‘write’ means everytime gradient is write to specified <cite>args_grad</cite> <cite>NDArray</cite>.</li>
<li>‘add’ means everytime gradient is add to the specified NDArray.</li>
<li>‘null’ means no action is taken, the gradient may not be calculated.</li>
</ul>
</li>
<li><strong>aux_states</strong> (list of <cite>NDArray</cite>, or dict of str to <cite>NDArray</cite>, optional) – <p>Input auxiliary states to the symbol, only needed when the output of
<cite>list_auxiliary_states()</cite> is not empty.</p>
<ul>
<li>If the input type is a list of <cite>NDArray</cite>, the order should be same as the order
of <cite>list_auxiliary_states()</cite>.</li>
<li>If the input type is a dict of str to <cite>NDArray</cite>, then it maps the name of
<cite>auxiliary_states</cite> to the corresponding <cite>NDArray</cite>,</li>
<li>In either case, all the auxiliary states need to be provided.</li>
</ul>
</li>
<li><strong>group2ctx</strong> (<em>Dict of string to mx.Context</em>) – The dict mapping the <cite>ctx_group</cite> attribute to the context assignment.</li>
<li><strong>shared_exec</strong> (<em>mx.executor.Executor</em>) – Executor to share memory with. This is intended for runtime reshaping, variable length
sequences, etc. The returned executor shares state with <cite>shared_exec</cite>, and should not be
used in parallel with it.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>executor</strong> –
The generated executor</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Executor</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Auxiliary states are the special states of symbols that do not correspond
to an argument, and do not have gradient but are still useful
for the specific operations. Common examples of auxiliary states include
the <cite>moving_mean</cite> and <cite>moving_variance</cite> states in <cite>BatchNorm</cite>.
Most operators do not have auxiliary states and in those cases,
this parameter can be safely ignored.</p>
<p>One can give up gradient by using a dict in <cite>args_grad</cite> and only specify
gradient they interested in.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>wrt</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the autodiff of current symbol.</p>
<p>This function can only be used if current symbol is a loss function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is currently not implemented.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wrt</strong> (<em>Array of String</em>) – keyword arguments of the symbol that the gradients are taken.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>grad</strong> –
A gradient Symbol with returns to be the corresponding gradients.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>ctx=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a symbol given arguments.</p>
<p>The <cite>eval</cite> method combines a call to <cite>bind</cite> (which returns an executor)
with a call to <cite>forward</cite> (executor method).
For the common use case, where you might repeatedly evaluate with same arguments,
eval is slow.
In that case, you should call <cite>bind</cite> once and then repeatedly call forward.
This function allows simpler syntax for less cumbersome introspection.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">ex</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">>>> </span><span class="n">ex</span>
<span class="go">[<NDArray 2x3 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">ex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ctx</strong> (<em>Context</em>) – The device context the generated executor to run on.</li>
<li><strong>kwargs</strong> (Keyword arguments of type <cite>NDArray</cite>) – Input arguments to the symbol. All the arguments must be provided.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>result</strong> (<em>a list of NDArrays corresponding to the values taken by each symbol when</em>)</li>
<li><em>evaluated on given args. When called on a single symbol (not a group),</em></li>
<li><em>the result will be a list with one element.</em></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.symbol.Symbol.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Symbol.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for mxnet.sym.reshape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>tuple of int</em>) – The new shape should not change the array size, namely
<code class="docutils literal"><span class="pre">np.prod(new_shape)</span></code> should be equal to <code class="docutils literal"><span class="pre">np.prod(self.shape)</span></code>.
One shape dimension can be -1. In this case, the value is inferred
from the length of the array and remaining dimensions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A reshaped symbol.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.var">
<code class="descclassname">mxnet.symbol.</code><code class="descname">var</code><span class="sig-paren">(</span><em>name</em>, <em>attr=None</em>, <em>shape=None</em>, <em>lr_mult=None</em>, <em>wd_mult=None</em>, <em>dtype=None</em>, <em>init=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a symbolic variable with specified name.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="s1">'b'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">data</span>
<span class="go"><Symbol data></span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) – Variable name.</li>
<li><strong>attr</strong> (<em>Dict of strings</em>) – Additional attributes to set on the variable. Format {string : string}.</li>
<li><strong>shape</strong> (<em>tuple</em>) – The shape of a variable. If specified, this will be used during the shape inference.
If one has specified a different shape for this variable using
a keyword argument when calling shape inference, this shape information will be ignored.</li>
<li><strong>lr_mult</strong> (<em>float</em>) – The learning rate multiplier for input variable.</li>
<li><strong>wd_mult</strong> (<em>float</em>) – Weight decay multiplier for input variable.</li>
<li><strong>dtype</strong> (<em>str or numpy.dtype</em>) – The dtype for input variable. If not specified, this value will be inferred.</li>
<li><strong>init</strong> (<em>initializer (mxnet.init.*)</em>) – Initializer for this variable to (optionally) override the default initializer.</li>
<li><strong>kwargs</strong> (<em>Additional attribute variables</em>) – Additional attributes must start and end with double underscores.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>variable</strong> –
A symbol corresponding to an input to the computation graph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Variable">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Variable</code><span class="sig-paren">(</span><em>name</em>, <em>attr=None</em>, <em>shape=None</em>, <em>lr_mult=None</em>, <em>wd_mult=None</em>, <em>dtype=None</em>, <em>init=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a symbolic variable with specified name.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="s1">'b'</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">data</span>
<span class="go"><Symbol data></span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) – Variable name.</li>
<li><strong>attr</strong> (<em>Dict of strings</em>) – Additional attributes to set on the variable. Format {string : string}.</li>
<li><strong>shape</strong> (<em>tuple</em>) – The shape of a variable. If specified, this will be used during the shape inference.
If one has specified a different shape for this variable using
a keyword argument when calling shape inference, this shape information will be ignored.</li>
<li><strong>lr_mult</strong> (<em>float</em>) – The learning rate multiplier for input variable.</li>
<li><strong>wd_mult</strong> (<em>float</em>) – Weight decay multiplier for input variable.</li>
<li><strong>dtype</strong> (<em>str or numpy.dtype</em>) – The dtype for input variable. If not specified, this value will be inferred.</li>
<li><strong>init</strong> (<em>initializer (mxnet.init.*)</em>) – Initializer for this variable to (optionally) override the default initializer.</li>
<li><strong>kwargs</strong> (<em>Additional attribute variables</em>) – Additional attributes must start and end with double underscores.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>variable</strong> –
A symbol corresponding to an input to the computation graph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Group">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Group</code><span class="sig-paren">(</span><em>symbols</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a symbol that contains a collection of other symbols, grouped together.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Group</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
<span class="go"><Symbol Grouped></span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>symbols</strong> (<em>list</em>) – List of symbols to be grouped.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>sym</strong> –
A group symbol.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.load">
<code class="descclassname">mxnet.symbol.</code><code class="descname">load</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads symbol from a JSON file.</p>
<p>You can also use pickle to do the job if you only work on python.
The advantage of load/save is the file is language agnostic.
This means the file saved using save can be loaded by other language binding of mxnet.
You also get the benefit being able to directly load/save from cloud storage(S3, HDFS).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) – <p>The name of the file, examples:</p>
<ul class="simple">
<li><cite>s3://my-bucket/path/my-s3-symbol</cite></li>
<li><cite>hdfs://my-bucket/path/my-hdfs-symbol</cite></li>
<li><cite>/path-to/my-local-symbol</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>sym</strong> –
The loaded symbol.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#mxnet.symbol.Symbol.save" title="mxnet.symbol.Symbol.save"><code class="xref py py-func docutils literal"><span class="pre">Symbol.save()</span></code></a></dt>
<dd>Used to save symbol into file.</dd>
</dl>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.load_json">
<code class="descclassname">mxnet.symbol.</code><code class="descname">load_json</code><span class="sig-paren">(</span><em>json_str</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.load_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads symbol from json string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_str</strong> (<em>str</em>) – A JSON string.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>sym</strong> –
The loaded symbol.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#mxnet.symbol.Symbol.tojson" title="mxnet.symbol.Symbol.tojson"><code class="xref py py-func docutils literal"><span class="pre">Symbol.tojson()</span></code></a></dt>
<dd>Used to save symbol into json string.</dd>
</dl>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.pow">
<code class="descclassname">mxnet.symbol.</code><code class="descname">pow</code><span class="sig-paren">(</span><em>base</em>, <em>exp</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise result of base element raised to powers from exp element.</p>
<p>Both inputs can be Symbol or scalar number.
Broadcasting is not supported. Use <cite>broadcast_pow</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base</strong> (<em>Symbol or scalar</em>) – The base symbol</li>
<li><strong>exp</strong> (<em>Symbol or scalar</em>) – The exponent symbol</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The bases in x raised to the exponents in y.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Symbol or scalar</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 1.,  4.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([  9.,  27.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">y</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([  9.,  64.], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.maximum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">maximum</code><span class="sig-paren">(</span><em>left</em>, <em>right</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise maximum of the input elements.</p>
<p>Both inputs can be Symbol or scalar number. Broadcasting is not supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<em>Symbol or scalar</em>) – First symbol to be compared.</li>
<li><strong>right</strong> (<em>Symbol or scalar</em>) – Second symbol to be compared.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise maximum of the input symbols.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Symbol or scalar</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([  4.,   5.,   4.,  10.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">y</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 10.,   4.], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.minimum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">minimum</code><span class="sig-paren">(</span><em>left</em>, <em>right</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise minimum of the input elements.</p>
<p>Both inputs can be Symbol or scalar number. Broadcasting is not supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<em>Symbol or scalar</em>) – First symbol to be compared.</li>
<li><strong>right</strong> (<em>Symbol or scalar</em>) – Second symbol to be compared.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise minimum of the input symbols.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Symbol or scalar</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 3.,  4.,  2.,  4.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">y</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 3.,  2.], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.hypot">
<code class="descclassname">mxnet.symbol.</code><code class="descname">hypot</code><span class="sig-paren">(</span><em>left</em>, <em>right</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.hypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the “legs” of a right triangle, returns its hypotenuse.</p>
<p>Equivalent to <span class="math">\(\sqrt(left^2 + right^2)\)</span>, element-wise.
Both inputs can be Symbol or scalar number. Broadcasting is not supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<em>Symbol or scalar</em>) – First leg of the triangle(s).</li>
<li><strong>right</strong> (<em>Symbol or scalar</em>) – Second leg of the triangle(s).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The hypotenuse of the triangle(s)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Symbol or scalar</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 5.,  6.40312433,  4.47213602], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">y</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 10.44030666,   4.47213602], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.zeros">
<code class="descclassname">mxnet.symbol.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new symbol of given shape and type, filled with zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int or sequence of ints</em>) – Shape of the new array.</li>
<li><strong>dtype</strong> (<em>str or numpy.dtype, optional</em>) – The value type of the inner value, default to <code class="docutils literal"><span class="pre">np.float32</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> –
The created Symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.ones">
<code class="descclassname">mxnet.symbol.</code><code class="descname">ones</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new symbol of given shape and type, filled with ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int or sequence of ints</em>) – Shape of the new array.</li>
<li><strong>dtype</strong> (<em>str or numpy.dtype, optional</em>) – The value type of the inner value, default to <code class="docutils literal"><span class="pre">np.float32</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> –
The created Symbol</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arange">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arange</code><span class="sig-paren">(</span><em>start</em>, <em>stop=None</em>, <em>step=1.0</em>, <em>repeat=1</em>, <em>name=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns evenly spaced values within a given interval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>number</em>) – Start of interval. The interval includes this value. The default start value is 0.</li>
<li><strong>stop</strong> (<em>number, optional</em>) – End of interval. The interval does not include this value.</li>
<li><strong>step</strong> (<em>number, optional</em>) – Spacing between values.</li>
<li><strong>repeat</strong> (<em>int, optional</em>) – “The repeating time of all elements.
E.g repeat=3, the element a will be repeated three times –> a, a, a.</li>
<li><strong>dtype</strong> (<em>str or numpy.dtype, optional</em>) – The value type of the inner value, default to <code class="docutils literal"><span class="pre">np.float32</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> –
The created Symbol</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Activation">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Activation</code><span class="sig-paren">(</span><em>data=None</em>, <em>act_type=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Activation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an activation function element-wise to the input.</p>
<p>The following activation functions are supported:</p>
<ul class="simple">
<li><cite>relu</cite>: Rectified Linear Unit, <span class="math">\(y = max(x, 0)\)</span></li>
<li><cite>sigmoid</cite>: <span class="math">\(y = \frac{1}{1 + exp(-x)}\)</span></li>
<li><cite>tanh</cite>: Hyperbolic tangent, <span class="math">\(y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}\)</span></li>
<li><cite>softrelu</cite>: Soft ReLU, or SoftPlus, <span class="math">\(y = log(1 + exp(x))\)</span></li>
</ul>
<p>Defined in src/operator/activation.cc:L73</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array to activation function.</li>
<li><strong>act_type</strong> (<em>{'relu', 'sigmoid', 'softrelu', 'tanh'}, required</em>) – Activation function to be applied.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>A one-hidden-layer MLP with ReLU activation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">mlp</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'proj'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">mlp</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mlp</span><span class="p">,</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'activation'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">mlp</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mlp</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'mlp'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">mlp</span>
<span class="go"><Symbol mlp></span>
</pre></div>
</div>
<p>ReLU activation</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">test_suites</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">'relu'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">'sigmoid'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">'tanh'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">'softrelu'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">random_arrays</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">>>> </span><span class="k">for</span> <span class="n">act_type</span><span class="p">,</span> <span class="n">numpy_impl</span> <span class="ow">in</span> <span class="n">test_suites</span><span class="p">:</span>
<span class="gp">... </span><span class="n">op</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">(</span><span class="n">act_type</span><span class="o">=</span><span class="n">act_type</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'act'</span><span class="p">)</span>
<span class="gp">... </span><span class="n">y</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">act_data</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span><span class="n">y_np</span> <span class="o">=</span> <span class="n">numpy_impl</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">act_type</span><span class="p">,</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">almost_equal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_np</span><span class="p">)))</span>
<span class="go">relu: True</span>
<span class="go">sigmoid: True</span>
<span class="go">tanh: True</span>
<span class="go">softrelu: True</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.BatchNorm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">BatchNorm</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>moving_mean=None</em>, <em>moving_var=None</em>, <em>eps=_Null</em>, <em>momentum=_Null</em>, <em>fix_gamma=_Null</em>, <em>use_global_stats=_Null</em>, <em>output_mean_var=_Null</em>, <em>axis=_Null</em>, <em>cudnn_off=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.BatchNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale <code class="docutils literal"><span class="pre">gamma</span></code> as
well as offset <code class="docutils literal"><span class="pre">beta</span></code>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:</p>
<div class="math">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>
have shape <em>(k,)</em>. If <code class="docutils literal"><span class="pre">output_mean_var</span></code> is set to be true, then outputs both <code class="docutils literal"><span class="pre">data_mean</span></code> and
<code class="docutils literal"><span class="pre">data_var</span></code> as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal"><span class="pre">moving_mean</span></code> and <code class="docutils literal"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated
by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">use_global_stats</span></code> is set to be true, then <code class="docutils literal"><span class="pre">moving_mean</span></code> and
<code class="docutils literal"><span class="pre">moving_var</span></code> are used instead of <code class="docutils literal"><span class="pre">data_mean</span></code> and <code class="docutils literal"><span class="pre">data_var</span></code> to compute
the output. It is often used during inference.</p>
<p>The parameter <code class="docutils literal"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’ (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.</p>
<p>Both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are learnable parameters. But if <code class="docutils literal"><span class="pre">fix_gamma</span></code> is true,
then set <code class="docutils literal"><span class="pre">gamma</span></code> to 1 and its gradient to 0.</p>
<p>Defined in src/operator/batch_norm.cc:L381</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to batch normalization</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – gamma array</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – beta array</li>
<li><strong>moving_mean</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – running mean of input</li>
<li><strong>moving_var</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – running variance of input</li>
<li><strong>eps</strong> (<em>float, optional, default=0.001</em>) – Epsilon to prevent div 0. Must be bigger than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><strong>momentum</strong> (<em>float, optional, default=0.9</em>) – Momentum for moving average</li>
<li><strong>fix_gamma</strong> (<em>boolean, optional, default=True</em>) – Fix gamma while training</li>
<li><strong>use_global_stats</strong> (<em>boolean, optional, default=False</em>) – Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><strong>output_mean_var</strong> (<em>boolean, optional, default=False</em>) – Output All,normal mean and var</li>
<li><strong>axis</strong> (<em>int, optional, default='1'</em>) – Specify which shape axis the channel is specified</li>
<li><strong>cudnn_off</strong> (<em>boolean, optional, default=False</em>) – Do not select CUDNN operator, if available</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.BatchNorm_v1">
<code class="descclassname">mxnet.symbol.</code><code class="descname">BatchNorm_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>eps=_Null</em>, <em>momentum=_Null</em>, <em>fix_gamma=_Null</em>, <em>use_global_stats=_Null</em>, <em>output_mean_var=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.BatchNorm_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale <code class="docutils literal"><span class="pre">gamma</span></code> as
well as offset <code class="docutils literal"><span class="pre">beta</span></code>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:</p>
<div class="math">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>
have shape <em>(k,)</em>. If <code class="docutils literal"><span class="pre">output_mean_var</span></code> is set to be true, then outputs both <code class="docutils literal"><span class="pre">data_mean</span></code> and
<code class="docutils literal"><span class="pre">data_var</span></code> as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal"><span class="pre">moving_mean</span></code> and <code class="docutils literal"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated
by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">use_global_stats</span></code> is set to be true, then <code class="docutils literal"><span class="pre">moving_mean</span></code> and
<code class="docutils literal"><span class="pre">moving_var</span></code> are used instead of <code class="docutils literal"><span class="pre">data_mean</span></code> and <code class="docutils literal"><span class="pre">data_var</span></code> to compute
the output. It is often used during inference.</p>
<p>Both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are learnable parameters. But if <code class="docutils literal"><span class="pre">fix_gamma</span></code> is true,
then set <code class="docutils literal"><span class="pre">gamma</span></code> to 1 and its gradient to 0.</p>
<p>Defined in src/operator/batch_norm_v1.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to batch normalization</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – gamma array</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – beta array</li>
<li><strong>eps</strong> (<em>float, optional, default=0.001</em>) – Epsilon to prevent div 0</li>
<li><strong>momentum</strong> (<em>float, optional, default=0.9</em>) – Momentum for moving average</li>
<li><strong>fix_gamma</strong> (<em>boolean, optional, default=True</em>) – Fix gamma while training</li>
<li><strong>use_global_stats</strong> (<em>boolean, optional, default=False</em>) – Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><strong>output_mean_var</strong> (<em>boolean, optional, default=False</em>) – Output All,normal mean and var</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.BilinearSampler">
<code class="descclassname">mxnet.symbol.</code><code class="descname">BilinearSampler</code><span class="sig-paren">(</span><em>data=None</em>, <em>grid=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.BilinearSampler" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Applies bilinear sampling to input feature map, which is the key of “[NIPS2015] Spatial Transformer Networks”</dt>
<dd>output[batch, channel, y_dst, x_dst] = G(data[batch, channel, y_src, x_src)
x_dst, y_dst enumerate all spatial locations in output
x_src = grid[batch, 0, y_dst, x_dst]
y_src = grid[batch, 1, y_dst, x_dst]
G() denotes the bilinear interpolation kernel</dd>
</dl>
<p>The out-boundary points will be padded as zeros. (The boundary is defined to be [-1, 1])
The shape of output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3])
The operator assumes that grid has been nomalized. If you want to design a CustomOp to manipulate grid, please refer to GridGeneratorOp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the BilinearsamplerOp.</li>
<li><strong>grid</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.BlockGrad">
<code class="descclassname">mxnet.symbol.</code><code class="descname">BlockGrad</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.BlockGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>v1 = [1, 2]
v2 = [0, 1]
a = Variable('a')
b = Variable('b')
b_stop_grad = stop_gradient(3 * b)
loss = MakeLoss(b_stop_grad + a)

executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
executor.forward(is_train=True, a=v1, b=v2)
executor.outputs
[ 1.  5.]

executor.backward()
executor.grad_arrays
[ 0.  0.]
[ 1.  1.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L99</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Cast">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Cast</code><span class="sig-paren">(</span><em>data=None</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts all elements of the input to a new type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Cast</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">cast</span></code> instead.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cast</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mf">1e20</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="mf">11.09375</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint8'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">253</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L175</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input.</li>
<li><strong>dtype</strong> (<em>{'float16', 'float32', 'float64', 'int32', 'uint8'}, required</em>) – Output data type.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Concat">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Concat</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins input arrays along a given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Concat</cite> is deprecated. Use <cite>concat</cite> instead.</p>
</div>
<p>The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[1,1],[2,2]]
y = [[3,3],[4,4],[5,5]]
z = [[6,6], [7,7],[8,8]]

concat(x,y,z,dim=0) = [[ 1.,  1.],
                       [ 2.,  2.],
                       [ 3.,  3.],
                       [ 4.,  4.],
                       [ 5.,  5.],
                       [ 6.,  6.],
                       [ 7.,  7.],
                       [ 8.,  8.]]

Note that you cannot concat x,y,z along dimension 1 since dimension
0 is not the same for all the input arrays.

concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                      [ 4.,  4.,  7.,  7.],
                      [ 5.,  5.,  8.,  8.]]
</pre></div>
</div>
<p>Defined in src/operator/concat.cc:L80
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol[]</em>) – List of arrays to concatenate</li>
<li><strong>dim</strong> (<em>int, optional, default='1'</em>) – the dimension to be concated.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Concat two (or more) inputs along a specific dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span> <span class="o">=</span> <span class="n">Concat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'my-concat'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">c</span>
<span class="go"><Symbol my-concat></span>
<span class="gp">>>> </span><span class="n">SymbolDoc</span><span class="o">.</span><span class="n">get_output_shape</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">{'my-concat_output': (128L, 25L, 3L, 3L)}</span>
</pre></div>
</div>
<p>Note the shape should be the same except on the dimension that is being
concatenated.</p>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Convolution">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Convolution</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</p>
<p>In the 2-D convolution, given input data with shape <em>(batch_size,
channel, height, width)</em>, the output is computed by</p>
<div class="math">
\[out[n,i,:,:] = bias[i] + \sum_{j=0}^{num\_filter} data[n,j,:,:] \star
weight[i,j,:,:]\]</div>
<p>where <span class="math">\(\star\)</span> is the 2-D cross-correlation operator.</p>
<p>For general 2-D convolution, the shapes are</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>.</li>
</ul>
<p>Define:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>then we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_height</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dilate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">out_width</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dilate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">no_bias</span></code> is set to be true, then the <code class="docutils literal"><span class="pre">bias</span></code> term is ignored.</p>
<p>The default data <code class="docutils literal"><span class="pre">layout</span></code> is <em>NCHW</em>, namely <em>(batch_size, channel, height,
width)</em>. We can choose other layouts such as <em>NHWC</em>.</p>
<p>If <code class="docutils literal"><span class="pre">num_group</span></code> is larger than 1, denoted by <em>g</em>, then split the input <code class="docutils literal"><span class="pre">data</span></code>
evenly into <em>g</em> parts along the channel axis, and also evenly split <code class="docutils literal"><span class="pre">weight</span></code>
along the first dimension. Next compute the convolution on the <em>i</em>-th part of
the data with the <em>i</em>-th weight part. The output is obtained by concatenating all
the <em>g</em> results.</p>
<p>1-D convolution does not have <em>height</em> dimension but only <em>width</em> in space.</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_width)</em>.</li>
</ul>
<p>3-D convolution adds an additional <em>depth</em> dimension besides <em>height</em> and
<em>width</em>. The shapes are</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, depth, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1], kernel[2])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_depth, out_height, out_width)</em>.</li>
</ul>
<p>Both <code class="docutils literal"><span class="pre">weight</span></code> and <code class="docutils literal"><span class="pre">bias</span></code> are learnable parameters.</p>
<p>There are other options to tune the performance.</p>
<ul class="simple">
<li><strong>cudnn_tune</strong>: enable this option leads to higher startup time but may give
faster speed. Options are<ul>
<li><strong>off</strong>: no tuning</li>
<li><strong>limited_workspace</strong>:run test and pick the fastest algorithm that doesn’t
exceed workspace limit.</li>
<li><strong>fastest</strong>: pick the fastest algorithm and ignore workspace limit.</li>
<li><strong>None</strong> (default): the behavior is determined by environment variable
<code class="docutils literal"><span class="pre">MXNET_CUDNN_AUTOTUNE_DEFAULT</span></code>. 0 for off, 1 for limited workspace
(default), 2 for fastest.</li>
</ul>
</li>
<li><strong>workspace</strong>: A large number leads to more (GPU) memory usage but may improve
the performance.</li>
</ul>
<p>Defined in src/operator/convolution.cc:L151</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the ConvolutionOp.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Bias parameter.</li>
<li><strong>kernel</strong> (<em>Shape(tuple), required</em>) – convolution kernel size: (h, w) or (d, h, w)</li>
<li><strong>stride</strong> (<em>Shape(tuple), optional, default=()</em>) – convolution stride: (h, w) or (d, h, w)</li>
<li><strong>dilate</strong> (<em>Shape(tuple), optional, default=()</em>) – convolution dilate: (h, w) or (d, h, w)</li>
<li><strong>pad</strong> (<em>Shape(tuple), optional, default=()</em>) – pad for convolution: (h, w) or (d, h, w)</li>
<li><strong>num_filter</strong> (<em>int (non-negative), required</em>) – convolution filter(channel) number</li>
<li><strong>num_group</strong> (<em>int (non-negative), optional, default=1</em>) – Number of group partitions.</li>
<li><strong>workspace</strong> (<em>long (non-negative), optional, default=1024</em>) – Maximum temporary workspace allowed for convolution (MB).</li>
<li><strong>no_bias</strong> (<em>boolean, optional, default=False</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</em>) – Whether to pick convolution algo by running performance test.</li>
<li><strong>cudnn_off</strong> (<em>boolean, optional, default=False</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</em>) – Set layout for input, output and weight. Empty for
default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Convolution_v1">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Convolution_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Convolution_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator is DEPRECATED. Apply convolution to input then add a bias.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the ConvolutionV1Op.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Bias parameter.</li>
<li><strong>kernel</strong> (<em>Shape(tuple), required</em>) – convolution kernel size: (h, w) or (d, h, w)</li>
<li><strong>stride</strong> (<em>Shape(tuple), optional, default=()</em>) – convolution stride: (h, w) or (d, h, w)</li>
<li><strong>dilate</strong> (<em>Shape(tuple), optional, default=()</em>) – convolution dilate: (h, w) or (d, h, w)</li>
<li><strong>pad</strong> (<em>Shape(tuple), optional, default=()</em>) – pad for convolution: (h, w) or (d, h, w)</li>
<li><strong>num_filter</strong> (<em>int (non-negative), required</em>) – convolution filter(channel) number</li>
<li><strong>num_group</strong> (<em>int (non-negative), optional, default=1</em>) – Number of group partitions. Equivalent to slicing input into num_group
partitions, apply convolution on each, then concatenate the results</li>
<li><strong>workspace</strong> (<em>long (non-negative), optional, default=1024</em>) – Maximum tmp workspace allowed for convolution (MB).</li>
<li><strong>no_bias</strong> (<em>boolean, optional, default=False</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</em>) – Whether to pick convolution algo by running performance test.
Leads to higher startup time but may give faster speed. Options are:
‘off’: no tuning
‘limited_workspace’: run test and pick the fastest algorithm that doesn’t exceed workspace limit.
‘fastest’: pick the fastest algorithm and ignore workspace limit.
If set to None (default), behavior is determined by environment
variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
1 for limited workspace (default), 2 for fastest.</li>
<li><strong>cudnn_off</strong> (<em>boolean, optional, default=False</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None, 'NCDHW', 'NCHW', 'NDHWC', 'NHWC'},optional, default='None'</em>) – Set layout for input, output and weight. Empty for
default layout: NCHW for 2d and NCDHW for 3d.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Correlation">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Correlation</code><span class="sig-paren">(</span><em>data1=None</em>, <em>data2=None</em>, <em>kernel_size=_Null</em>, <em>max_displacement=_Null</em>, <em>stride1=_Null</em>, <em>stride2=_Null</em>, <em>pad_size=_Null</em>, <em>is_multiply=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies correlation to inputs.</p>
<p>The correlation layer performs multiplicative patch comparisons between two feature maps.</p>
<p>Given two multi-channel feature maps <span class="math">\(f_{1}, f_{2}\)</span>, with <span class="math">\(w\)</span>, <span class="math">\(h\)</span>, and <span class="math">\(c\)</span> being their width, height, and number of channels,
the correlation layer lets the network compare each patch from <span class="math">\(f_{1}\)</span> with each patch from <span class="math">\(f_{2}\)</span>.</p>
<p>For now we consider only a single comparison of two patches. The ‘correlation’ of two patches centered at <span class="math">\(x_{1}\)</span> in the first map and
<span class="math">\(x_{2}\)</span> in the second map is then defined as:</p>
<div class="math">
\[\begin{split}c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\end{split}\]</div>
<p>for a square patch of size <span class="math">\(K:=2k+1\)</span>.</p>
<p>Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.</p>
<p>Computing <span class="math">\(c(x_{1}, x_{2})\)</span> involves <span class="math">\(c * K^{2}\)</span> multiplications. Comparing all patch combinations involves <span class="math">\(w^{2}*h^{2}\)</span> such computations.</p>
<p>Given a maximum displacement <span class="math">\(d\)</span>, for each location <span class="math">\(x_{1}\)</span> it computes correlations <span class="math">\(c(x_{1}, x_{2})\)</span> only in a neighborhood of size <span class="math">\(D:=2d+1\)</span>,
by limiting the range of <span class="math">\(x_{2}\)</span>. We use strides <span class="math">\(s_{1}, s_{2}\)</span>, to quantize <span class="math">\(x_{1}\)</span> globally and to quantize <span class="math">\(x_{2}\)</span> within the neighborhood
centered around <span class="math">\(x_{1}\)</span>.</p>
<p>The final output is defined by the following expression:</p>
<div class="math">
\[out[n, q, i, j] = c(x_{i, j}, x_{q})\]</div>
<p>where <span class="math">\(i\)</span> and <span class="math">\(j\)</span> enumerate spatial locations in <span class="math">\(f_{1}\)</span>, and <span class="math">\(q\)</span> denotes the <span class="math">\(q^{th}\)</span> neighborhood of <span class="math">\(x_{i,j}\)</span>.</p>
<p>Defined in src/operator/correlation.cc:L173</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data1</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data1 to the correlation.</li>
<li><strong>data2</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data2 to the correlation.</li>
<li><strong>kernel_size</strong> (<em>int (non-negative), optional, default=1</em>) – kernel size for Correlation must be an odd number</li>
<li><strong>max_displacement</strong> (<em>int (non-negative), optional, default=1</em>) – Max displacement of Correlation</li>
<li><strong>stride1</strong> (<em>int (non-negative), optional, default=1</em>) – stride1 quantize data1 globally</li>
<li><strong>stride2</strong> (<em>int (non-negative), optional, default=1</em>) – stride2 quantize data2 within the neighborhood centered around data1</li>
<li><strong>pad_size</strong> (<em>int (non-negative), optional, default=0</em>) – pad for Correlation</li>
<li><strong>is_multiply</strong> (<em>boolean, optional, default=True</em>) – operation type is either multiplication or subduction</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Crop">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Crop</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Crop" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Crop</cite> is deprecated. Use <cite>slice</cite> instead.</p>
</div>
<p>Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol’s size will be used</p>
<p>Defined in src/operator/crop.cc:L31
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol or Symbol[]</em>) – Tensor or List of Tensors, the second input will be used as crop_like shape reference</li>
<li><strong>offset</strong> (<em>Shape(tuple), optional, default=(0,0)</em>) – crop offset coordinate: (y, x)</li>
<li><strong>h_w</strong> (<em>Shape(tuple), optional, default=(0,0)</em>) – crop height and width: (h, w)</li>
<li><strong>center_crop</strong> (<em>boolean, optional, default=False</em>) – If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Custom">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Custom</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Custom" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a custom operator implemented in a frontend language (like Python).</p>
<p>Custom operators should override required methods like <cite>forward</cite> and <cite>backward</cite>.
The custom operator must be registered before it can be used.
Please check the tutorial here: <a class="reference external" href="http://mxnet.io/how_to/new_op.html">http://mxnet.io/how_to/new_op.html</a>.</p>
<p>Defined in src/operator/custom/custom.cc:L333</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol[]</em>) – Input data for the custom operator.</li>
<li><strong>op_type</strong> (<em>string</em>) – Name of the custom operator. This is the name that is passed to <cite>mx.operator.register</cite> to register the operator.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Deconvolution">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Deconvolution</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>adj=_Null</em>, <em>target_shape=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input tensor to the deconvolution operation.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weights representing the kernel.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Bias added to the result after the deconvolution operation.</li>
<li><strong>kernel</strong> (<em>Shape(tuple), required</em>) – Deconvolution kernel size: (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</li>
<li><strong>stride</strong> (<em>Shape(tuple), optional, default=()</em>) – The stride used for the corresponding convolution: (h, w) or (d, h, w).</li>
<li><strong>dilate</strong> (<em>Shape(tuple), optional, default=()</em>) – Dilation factor for each dimension of the input: (h, w) or (d, h, w).</li>
<li><strong>pad</strong> (<em>Shape(tuple), optional, default=()</em>) – The amount of implicit zero padding added during convolution for each dimension of the input: (h, w) or (d, h, w). <code class="docutils literal"><span class="pre">(kernel-1)/2</span></code> is usually a good choice. If <cite>target_shape</cite> is set, <cite>pad</cite> will be ignored and a padding that will generate the target shape will be used.</li>
<li><strong>adj</strong> (<em>Shape(tuple), optional, default=()</em>) – Adjustment for output shape: (h, w) or (d, h, w). If <cite>target_shape</cite> is set, <cite>adj</cite> will be ignored and computed accordingly.</li>
<li><strong>target_shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output tensor: (h, w) or (d, h, w).</li>
<li><strong>num_filter</strong> (<em>int (non-negative), required</em>) – Number of output filters.</li>
<li><strong>num_group</strong> (<em>int (non-negative), optional, default=1</em>) – Number of groups partition.</li>
<li><strong>workspace</strong> (<em>long (non-negative), optional, default=512</em>) – Maximum temporal workspace allowed for deconvolution (MB).</li>
<li><strong>no_bias</strong> (<em>boolean, optional, default=True</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</em>) – Whether to pick convolution algorithm by running performance test.</li>
<li><strong>cudnn_off</strong> (<em>boolean, optional, default=False</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</em>) – Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Dropout">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Dropout</code><span class="sig-paren">(</span><em>data=None</em>, <em>p=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies dropout operation to input array.</p>
<ul class="simple">
<li>During training, each element of the input is set to zero with probability p.
The whole array is rescaled by <span class="math">\(1/(1-p)\)</span> to keep the expected
sum of the input unchanged.</li>
<li>During testing, this operator does not change the input.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>random.seed(998)
input_array = array([[3., 0.5,  -0.5,  2., 7.],
                    [2., -0.4,   7.,  3., 0.2]])
a = symbol.Variable('a')
dropout = symbol.Dropout(a, p = 0.2)
executor = dropout.simple_bind(a = input_array.shape)

## If training
executor.forward(is_train = True, a = input_array)
executor.outputs
[[ 3.75   0.625 -0.     2.5    8.75 ]
 [ 2.5   -0.5    8.75   3.75   0.   ]]

## If testing
executor.forward(is_train = False, a = input_array)
executor.outputs
[[ 3.     0.5   -0.5    2.     7.   ]
 [ 2.    -0.4    7.     3.     0.2  ]]
</pre></div>
</div>
<p>Defined in src/operator/dropout.cc:L58</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array to which dropout will be applied.</li>
<li><strong>p</strong> (<em>float, optional, default=0.5</em>) – Fraction of the input that gets dropped out during training time.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Apply dropout to corrupt input as zero with probability 0.2:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">data_dp</span> <span class="o">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># take larger shapes to be more statistical stable</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'dp'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="c1"># dropout is identity during testing</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">dp_data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">is_train</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">test_utils</span><span class="o">.</span><span class="n">almost_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">dp_data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">is_train</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">>>> </span><span class="c1"># expectation is (approximately) unchanged</span>
<span class="gp">>>> </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o"><</span> <span class="mf">0.1</span>
<span class="go">True</span>
<span class="gp">>>> </span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.ElementWiseSum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">ElementWiseSum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.ElementWiseSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all input arguments element-wise.</p>
<div class="math">
\[add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\]</div>
<p><code class="docutils literal"><span class="pre">add_n</span></code> is potentially more efficient than calling <code class="docutils literal"><span class="pre">add</span></code> by <cite>n</cite> times.</p>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L47
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>Symbol[]</em>) – Positional input arguments</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Embedding">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Embedding</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>input_dim=_Null</em>, <em>output_dim=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).</p>
<p>If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>input_dim = 4
output_dim = 5

// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
y = [[  0.,   1.,   2.,   3.,   4.],
     [  5.,   6.,   7.,   8.,   9.],
     [ 10.,  11.,  12.,  13.,  14.],
     [ 15.,  16.,  17.,  18.,  19.]]

// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
x = [[ 1.,  3.],
     [ 0.,  2.]]

// Mapped input x to its vector representation y.
Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
                          [ 15.,  16.,  17.,  18.,  19.]],

                         [[  0.,   1.,   2.,   3.,   4.],
                          [ 10.,  11.,  12.,  13.,  14.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L55</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array to the embedding operator.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The embedding weight matrix.</li>
<li><strong>input_dim</strong> (<em>int, required</em>) – Vocabulary size of the input indices.</li>
<li><strong>output_dim</strong> (<em>int, required</em>) – Dimension of the embedding vectors.</li>
<li><strong>dtype</strong> (<em>{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</em>) – Data type of weight.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Assume we want to map the 26 English alphabet letters to 16-dimensional
vectorial representations.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">vocabulary_size</span> <span class="o">=</span> <span class="mi">26</span>
<span class="gp">>>> </span><span class="n">embed_dim</span> <span class="o">=</span> <span class="mi">16</span>
<span class="gp">>>> </span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">input</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'letters'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">input_dim</span><span class="o">=</span><span class="n">vocabulary_size</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">embed_dim</span><span class="p">,</span>
<span class="go">...name='embed')</span>
<span class="gp">>>> </span><span class="n">SymbolDoc</span><span class="o">.</span><span class="n">get_output_shape</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">letters</span><span class="o">=</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">))</span>
<span class="go">{'embed_output': (10L, 64L, 16L)}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">embed_dim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">>>> </span><span class="n">word_vecs</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">random_arrays</span><span class="p">((</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'embed'</span><span class="p">,</span> <span class="n">input_dim</span><span class="o">=</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">embed_dim</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">embed_data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">embed_weight</span><span class="o">=</span><span class="n">word_vecs</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y_np</span> <span class="o">=</span> <span class="n">word_vecs</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">>>> </span><span class="n">test_utils</span><span class="o">.</span><span class="n">almost_equal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_np</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Flatten">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Flatten</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Flatten</cite> is deprecated. Use <cite>flatten</cite> instead.</p>
</div>
<p>For an input array with shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>, <cite>flatten</cite> operation reshapes
the input array into an output array of shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">],</span>
<span class="p">[</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">]],</span>

<span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L132</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Flatten is usually applied before <cite>FullyConnected</cite>, to reshape the 4D tensor
produced by convolutional layers to 2D matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>  <span class="c1"># say this is 4D from some conv/pool</span>
<span class="gp">>>> </span><span class="n">flatten</span> <span class="o">=</span> <span class="n">Flatten</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'flat'</span><span class="p">)</span>  <span class="c1"># now this is 2D</span>
<span class="gp">>>> </span><span class="n">SymbolDoc</span><span class="o">.</span><span class="n">get_output_shape</span><span class="p">(</span><span class="n">flatten</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">{'flat_output': (2L, 60L)}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">test_dims</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)]</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">Flatten</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'flat'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="k">for</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">test_dims</span><span class="p">:</span>
<span class="gp">... </span><span class="n">x</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">random_arrays</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
<span class="gp">... </span><span class="n">y</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">flat_data</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span><span class="n">y_np</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)))</span>
<span class="gp">... </span><span class="k">print</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">almost_equal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_np</span><span class="p">)))</span>
<span class="go">(2, 3, 4, 5): True</span>
<span class="go">(2, 3): True</span>
<span class="go">(2,): True</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.FullyConnected">
<code class="descclassname">mxnet.symbol.</code><code class="descname">FullyConnected</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>num_hidden=_Null</em>, <em>no_bias=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.FullyConnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a linear transformation: <span class="math">\(Y = XW^T + b\)</span>.</p>
<p>Shapes:</p>
<ul class="simple">
<li><strong>data</strong>: <cite>(batch_size, input_dim)</cite></li>
<li><strong>weight</strong>: <cite>(num_hidden, input_dim)</cite></li>
<li><strong>bias</strong>: <cite>(num_hidden,)</cite></li>
<li><strong>out</strong>: <cite>(batch_size, num_hidden)</cite></li>
</ul>
<p>The learnable parameters include both <code class="docutils literal"><span class="pre">weight</span></code> and <code class="docutils literal"><span class="pre">bias</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">no_bias</span></code> is set to be true, then the <code class="docutils literal"><span class="pre">bias</span></code> term is ignored.</p>
<p>Defined in src/operator/fully_connected.cc:L72</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Bias parameter.</li>
<li><strong>num_hidden</strong> (<em>int, required</em>) – Number of hidden nodes of the output.</li>
<li><strong>no_bias</strong> (<em>boolean, optional, default=False</em>) – Whether to disable bias parameter.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Construct a fully connected operator with target dimension 512.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">data</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>  <span class="c1"># or some constructed NN</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">... </span><span class="n">num_hidden</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="gp">... </span><span class="n">name</span><span class="o">=</span><span class="s1">'FC1'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">op</span>
<span class="go"><Symbol FC1></span>
<span class="gp">>>> </span><span class="n">SymbolDoc</span><span class="o">.</span><span class="n">get_output_shape</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="go">{'FC1_output': (128L, 512L)}</span>
</pre></div>
</div>
<p>A simple 3-layer MLP with ReLU activation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">net</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'data'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">]):</span>
<span class="gp">... </span><span class="n">net</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">net</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'FC</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span><span class="n">net</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">net</span><span class="p">,</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'ReLU</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">>>> </span><span class="c1"># 10-class predictor (e.g. MNIST)</span>
<span class="gp">>>> </span><span class="n">net</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">net</span><span class="p">,</span> <span class="n">num_hidden</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'pred'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">net</span>
<span class="go"><Symbol pred></span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">dim_in</span><span class="p">,</span> <span class="n">dim_out</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">random_arrays</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="n">dim_in</span><span class="p">),</span> <span class="p">(</span><span class="n">dim_out</span><span class="p">,</span> <span class="n">dim_in</span><span class="p">),</span> <span class="p">(</span><span class="n">dim_out</span><span class="p">,))</span>
<span class="gp">>>> </span><span class="n">op</span> <span class="o">=</span> <span class="n">FullyConnected</span><span class="p">(</span><span class="n">num_hidden</span><span class="o">=</span><span class="n">dim_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'FC'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">out</span> <span class="o">=</span> <span class="n">test_utils</span><span class="o">.</span><span class="n">simple_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">FC_data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">FC_weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">FC_bias</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">>>> </span><span class="c1"># numpy implementation of FullyConnected</span>
<span class="gp">>>> </span><span class="n">out_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">>>> </span><span class="n">test_utils</span><span class="o">.</span><span class="n">almost_equal</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out_np</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.GridGenerator">
<code class="descclassname">mxnet.symbol.</code><code class="descname">GridGenerator</code><span class="sig-paren">(</span><em>data=None</em>, <em>transform_type=_Null</em>, <em>target_shape=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.GridGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates 2D sampling grid for bilinear sampling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the function.</li>
<li><strong>transform_type</strong> (<em>{'affine', 'warp'}, required</em>) – The type of transformation. For <cite>affine</cite>, input data should be an affine matrix of size (batch, 6). For <cite>warp</cite>, input data should be an optical flow of size (batch, 2, h, w).</li>
<li><strong>target_shape</strong> (<em>Shape(tuple), optional, default=(0,0)</em>) – Specifies the output shape (H, W). This is required if transformation type is <cite>affine</cite>. If transformation type is <cite>warp</cite>, this parameter is ignored.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.IdentityAttachKLSparseReg">
<code class="descclassname">mxnet.symbol.</code><code class="descname">IdentityAttachKLSparseReg</code><span class="sig-paren">(</span><em>data=None</em>, <em>sparseness_target=_Null</em>, <em>penalty=_Null</em>, <em>momentum=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.IdentityAttachKLSparseReg" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a sparse regularization to the output a sigmoid activation function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data.</li>
<li><strong>sparseness_target</strong> (<em>float, optional, default=0.1</em>) – The sparseness target</li>
<li><strong>penalty</strong> (<em>float, optional, default=0.001</em>) – The tradeoff parameter for the sparseness penalty</li>
<li><strong>momentum</strong> (<em>float, optional, default=0.9</em>) – The momentum for running average</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.InstanceNorm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">InstanceNorm</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>eps=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.InstanceNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies instance normalization to the n-dimensional input array.</p>
<p>This operator takes an n-dimensional input array where (n>2) and normalizes
the input using the following formula:</p>
<div class="math">
\[out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta\]</div>
<p>This layer is similar to batch normalization layer (<cite>BatchNorm</cite>)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as <cite>contrast normalization</cite>.</p>
<p>If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
<cite>gamma</cite> and <cite>beta</cite> parameters must be vectors of shape [channel].</p>
<p>This implementation is based on paper:</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Instance Normalization: The Missing Ingredient for Fast Stylization,
D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).</td></tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Input of shape (2,1,2)
x = [[[ 1.1,  2.2]],
     [[ 3.3,  4.4]]]

// gamma parameter of length 1
gamma = [1.5]

// beta parameter of length 1
beta = [0.5]

// Instance normalization is calculated with the above formula
InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
                              [[-0.99752653,  1.99752724]]]
</pre></div>
</div>
<p>Defined in src/operator/instance_norm.cc:L76</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – An n-dimensional input array (n > 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – A vector of length ‘channel’, which multiplies the normalized input.</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – A vector of length ‘channel’, which is added to the product of the normalized input and the weight.</li>
<li><strong>eps</strong> (<em>float, optional, default=0.001</em>) – An <cite>epsilon</cite> parameter to prevent division by 0.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.L2Normalization">
<code class="descclassname">mxnet.symbol.</code><code class="descname">L2Normalization</code><span class="sig-paren">(</span><em>data=None</em>, <em>eps=_Null</em>, <em>mode=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.L2Normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the input array using the L2 norm.</p>
<p>For 1-D NDArray, it computes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D NDArray, if the input array has shape (N, N, ..., N),</p>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">instance</span></code>, it normalizes each instance in the multidimensional
array by its L2 norm.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>for i in 0...N
  out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">channel</span></code>, it normalizes each channel in the array by its L2 norm.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>for i in 0...N
  out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">spatial</span></code>, it normalizes the cross channel norm for each position
in the array by its L2 norm.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>for dim in 2...N
  for i in 0...N
    out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
        -dim-
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[1,2],
      [3,4]],
     [[2,2],
      [5,6]]]

L2Normalization(x, mode='instance')
=[[[ 0.18257418  0.36514837]
   [ 0.54772252  0.73029673]]
  [[ 0.24077171  0.24077171]
   [ 0.60192931  0.72231513]]]

L2Normalization(x, mode='channel')
=[[[ 0.31622776  0.44721359]
   [ 0.94868326  0.89442718]]
  [[ 0.37139067  0.31622776]
   [ 0.92847669  0.94868326]]]

L2Normalization(x, mode='spatial')
=[[[ 0.44721359  0.89442718]
   [ 0.60000002  0.80000001]]
  [[ 0.70710677  0.70710677]
   [ 0.6401844   0.76822126]]]
</pre></div>
</div>
<p>Defined in src/operator/l2_normalization.cc:L74</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array to normalize.</li>
<li><strong>eps</strong> (<em>float, optional, default=1e-10</em>) – A small constant for numerical stability.</li>
<li><strong>mode</strong> (<em>{'channel', 'instance', 'spatial'},optional, default='instance'</em>) – Specify the dimension along which to compute L2 norm.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.LRN">
<code class="descclassname">mxnet.symbol.</code><code class="descname">LRN</code><span class="sig-paren">(</span><em>data=None</em>, <em>alpha=_Null</em>, <em>beta=_Null</em>, <em>knorm=_Null</em>, <em>nsize=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.LRN" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies local response normalization to the input.</p>
<p>The local response normalization layer performs “lateral inhibition” by normalizing
over local input regions.</p>
<p>If <span class="math">\(a_{x,y}^{i}\)</span> is the activity of a neuron computed by applying kernel <span class="math">\(i\)</span> at position
<span class="math">\((x, y)\)</span> and then applying the ReLU nonlinearity, the response-normalized
activity <span class="math">\(b_{x,y}^{i}\)</span> is given by the expression:</p>
<div class="math">
\[b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \alpha \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}\]</div>
<p>where the sum runs over <span class="math">\(n\)</span> “adjacent” kernel maps at the same spatial position, and <span class="math">\(N\)</span> is the total
number of kernels in the layer.</p>
<p>Defined in src/operator/lrn.cc:L54</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data.</li>
<li><strong>alpha</strong> (<em>float, optional, default=0.0001</em>) – The variance scaling parameter <span class="math">\(lpha\)</span> in the LRN expression.</li>
<li><strong>beta</strong> (<em>float, optional, default=0.75</em>) – The power parameter <span class="math">\(eta\)</span> in the LRN expression.</li>
<li><strong>knorm</strong> (<em>float, optional, default=2</em>) – The parameter <span class="math">\(k\)</span> in the LRN expression.</li>
<li><strong>nsize</strong> (<em>int (non-negative), required</em>) – normalization window width in elements.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.LeakyReLU">
<code class="descclassname">mxnet.symbol.</code><code class="descname">LeakyReLU</code><span class="sig-paren">(</span><em>data=None</em>, <em>act_type=_Null</em>, <em>slope=_Null</em>, <em>lower_bound=_Null</em>, <em>upper_bound=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.LeakyReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies Leaky rectified linear unit activation element-wise to the input.</p>
<p>Leaky ReLUs attempt to fix the “dying ReLU” problem by allowing a small <cite>slope</cite>
when the input is negative and has a slope of one when input is positive.</p>
<p>The following modified ReLU Activation functions are supported:</p>
<ul class="simple">
<li><em>elu</em>: Exponential Linear Unit. <cite>y = x > 0 ? x : slope * (exp(x)-1)</cite></li>
<li><em>leaky</em>: Leaky ReLU. <cite>y = x > 0 ? x : slope * x</cite></li>
<li><em>prelu</em>: Parametric ReLU. This is same as <em>leaky</em> except that <cite>slope</cite> is learnt during training.</li>
<li><em>rrelu</em>: Randomized ReLU. same as <em>leaky</em> but the <cite>slope</cite> is uniformly and randomly chosen from
<em>[lower_bound, upper_bound)</em> for training, while fixed to be
<em>(lower_bound+upper_bound)/2</em> for inference.</li>
</ul>
<p>Defined in src/operator/leaky_relu.cc:L39</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to activation function.</li>
<li><strong>act_type</strong> (<em>{'elu', 'leaky', 'prelu', 'rrelu'},optional, default='leaky'</em>) – Activation function to be applied.</li>
<li><strong>slope</strong> (<em>float, optional, default=0.25</em>) – Init slope for the activation. (For leaky and elu only)</li>
<li><strong>lower_bound</strong> (<em>float, optional, default=0.125</em>) – Lower bound of random slope. (For rrelu only)</li>
<li><strong>upper_bound</strong> (<em>float, optional, default=0.334</em>) – Upper bound of random slope. (For rrelu only)</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.LinearRegressionOutput">
<code class="descclassname">mxnet.symbol.</code><code class="descname">LinearRegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.LinearRegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and optimizes for squared loss during backward propagation.
Just outputs <code class="docutils literal"><span class="pre">data</span></code> during forward propagation.</p>
<p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the i-th sample, and <span class="math">\(y_i\)</span> is the corresponding target value,
then the squared loss estimated over <span class="math">\(n\)</span> samples is defined as</p>
<p><span class="math">\(\text{SquaredLoss}(y, \hat{y} ) = \frac{1}{n} \sum_{i=0}^{n-1} \left( y_i - \hat{y}_i \right)^2\)</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the LinearRegressionOutput as the final output layer of a net.</p>
</div>
<p>By default, gradients of this loss function are scaled by factor <cite>1/n</cite>, where n is the number of training examples.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/n</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L51</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.LogisticRegressionOutput">
<code class="descclassname">mxnet.symbol.</code><code class="descname">LogisticRegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.LogisticRegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a logistic function to the input.</p>
<p>The logistic function, also known as the sigmoid function, is computed as
<span class="math">\(\frac{1}{1+exp(-x)}\)</span>.</p>
<p>Commonly, the sigmoid is used to squash the real-valued output of a linear model
:math:wTx+b into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the LogisticRegressionOutput as the final output layer of a net.</p>
</div>
<p>By default, gradients of this loss function are scaled by factor <cite>1/n</cite>, where n is the number of training examples.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/n</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L93</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.MAERegressionOutput">
<code class="descclassname">mxnet.symbol.</code><code class="descname">MAERegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.MAERegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mean absolute error of the input.</p>
<p>MAE is a risk metric corresponding to the expected value of the absolute error.</p>
<p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the i-th sample, and <span class="math">\(y_i\)</span> is the corresponding target value,
then the mean absolute error (MAE) estimated over <span class="math">\(n\)</span> samples is defined as</p>
<p><span class="math">\(\text{MAE}(y, \hat{y} ) = \frac{1}{n} \sum_{i=0}^{n-1} \left| y_i - \hat{y}_i \right|\)</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the MAERegressionOutput as the final output layer of a net.</p>
</div>
<p>By default, gradients of this loss function are scaled by factor <cite>1/n</cite>, where n is the number of training examples.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/n</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L72</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.MakeLoss">
<code class="descclassname">mxnet.symbol.</code><code class="descname">MakeLoss</code><span class="sig-paren">(</span><em>data=None</em>, <em>grad_scale=_Null</em>, <em>valid_thresh=_Null</em>, <em>normalization=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.MakeLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume <code class="docutils literal"><span class="pre">out</span></code> is the
predicted output and <code class="docutils literal"><span class="pre">label</span></code> is the true label, then the cross entropy can be defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">MakeLoss</span><span class="p">(</span><span class="n">cross_entropy</span><span class="p">)</span>
</pre></div>
</div>
<p>We will need to use <code class="docutils literal"><span class="pre">MakeLoss</span></code> when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables’ gradients
from backpropagation. See more detail in <code class="docutils literal"><span class="pre">BlockGrad</span></code> or <code class="docutils literal"><span class="pre">stop_gradient</span></code>.</p>
<p>In addition, we can give a scale to the loss by setting <code class="docutils literal"><span class="pre">grad_scale</span></code>,
so that the gradient of the loss will be rescaled in the backpropagation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator should be used as a Symbol instead of NDArray.</p>
</div>
<p>Defined in src/operator/make_loss.cc:L52</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Gradient scale as a supplement to unary and binary operators</li>
<li><strong>valid_thresh</strong> (<em>float, optional, default=0</em>) – clip each element in the array to 0 when it is less than <code class="docutils literal"><span class="pre">valid_thresh</span></code>. This is used when <code class="docutils literal"><span class="pre">normalization</span></code> is set to <code class="docutils literal"><span class="pre">'valid'</span></code>.</li>
<li><strong>normalization</strong> (<em>{'batch', 'null', 'valid'},optional, default='null'</em>) – If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Pad">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Pad</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>pad_width=_Null</em>, <em>constant_value=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an input array with a constant or edge values of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Pad</cite> is deprecated. Use <cite>pad</cite> instead.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Current implementation only supports 4D and 5D input arrays with padding applied
only on axes 1, 2 and 3. Expects axes 4 and 5 in <cite>pad_width</cite> to be zero.</p>
</div>
<p>This operation pads an input array with either a <cite>constant_value</cite> or edge values
along each axis of the input array. The amount of padding is specified by <cite>pad_width</cite>.</p>
<p><cite>pad_width</cite> is a tuple of integer padding widths for each axis of the format
<code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. The <cite>pad_width</cite> should be of length <code class="docutils literal"><span class="pre">2*N</span></code>
where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.</p>
<p>For dimension <code class="docutils literal"><span class="pre">N</span></code> of the input array, <code class="docutils literal"><span class="pre">before_N</span></code> and <code class="docutils literal"><span class="pre">after_N</span></code> indicates how many values
to add before and after the elements of the array along dimension <code class="docutils literal"><span class="pre">N</span></code>.
The widths of the higher two dimensions <code class="docutils literal"><span class="pre">before_1</span></code>, <code class="docutils literal"><span class="pre">after_1</span></code>, <code class="docutils literal"><span class="pre">before_2</span></code>,
<code class="docutils literal"><span class="pre">after_2</span></code> must be 0.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[[  1.   2.   3.]
       [  4.   5.   6.]]

      [[  7.   8.   9.]
       [ 10.  11.  12.]]]


     [[[ 11.  12.  13.]
       [ 14.  15.  16.]]

      [[ 17.  18.  19.]
       [ 20.  21.  22.]]]]

pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

      [[[[  1.   1.   2.   3.   3.]
         [  1.   1.   2.   3.   3.]
         [  4.   4.   5.   6.   6.]
         [  4.   4.   5.   6.   6.]]

        [[  7.   7.   8.   9.   9.]
         [  7.   7.   8.   9.   9.]
         [ 10.  10.  11.  12.  12.]
         [ 10.  10.  11.  12.  12.]]]


       [[[ 11.  11.  12.  13.  13.]
         [ 11.  11.  12.  13.  13.]
         [ 14.  14.  15.  16.  16.]
         [ 14.  14.  15.  16.  16.]]

        [[ 17.  17.  18.  19.  19.]
         [ 17.  17.  18.  19.  19.]
         [ 20.  20.  21.  22.  22.]
         [ 20.  20.  21.  22.  22.]]]]

pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

      [[[[  0.   0.   0.   0.   0.]
         [  0.   1.   2.   3.   0.]
         [  0.   4.   5.   6.   0.]
         [  0.   0.   0.   0.   0.]]

        [[  0.   0.   0.   0.   0.]
         [  0.   7.   8.   9.   0.]
         [  0.  10.  11.  12.   0.]
         [  0.   0.   0.   0.   0.]]]


       [[[  0.   0.   0.   0.   0.]
         [  0.  11.  12.  13.   0.]
         [  0.  14.  15.  16.   0.]
         [  0.   0.   0.   0.   0.]]

        [[  0.   0.   0.   0.   0.]
         [  0.  17.  18.  19.   0.]
         [  0.  20.  21.  22.   0.]
         [  0.   0.   0.   0.   0.]]]]
</pre></div>
</div>
<p>Defined in src/operator/pad.cc:L747</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – An n-dimensional input array.</li>
<li><strong>mode</strong> (<em>{'constant', 'edge', 'reflect'}, required</em>) – Padding type to use. “constant” pads with <cite>constant_value</cite> “edge” pads using the edge values of the input array “reflect” pads by reflecting values with respect to the edges.</li>
<li><strong>pad_width</strong> (<em>Shape(tuple), required</em>) – Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. It should be of length <code class="docutils literal"><span class="pre">2*N</span></code> where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><strong>constant_value</strong> (<em>double, optional, default=0</em>) – The value used for padding when <cite>mode</cite> is “constant”.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Pooling">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Pooling</code><span class="sig-paren">(</span><em>data=None</em>, <em>global_pool=_Null</em>, <em>cudnn_off=_Null</em>, <em>kernel=_Null</em>, <em>pool_type=_Null</em>, <em>pooling_convention=_Null</em>, <em>stride=_Null</em>, <em>pad=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Pooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs pooling on the input.</p>
<p>The shapes for 1-D pooling are</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, width)</em>,</li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_width)</em>.</li>
</ul>
<p>The shapes for 2-D pooling are</p>
<ul>
<li><p class="first"><strong>data</strong>: <em>(batch_size, channel, height, width)</em></p>
</li>
<li><p class="first"><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>, with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_height</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">out_width</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<p>The definition of <em>f</em> depends on <code class="docutils literal"><span class="pre">pooling_convention</span></code>, which has two options:</p>
<ul>
<li><p class="first"><strong>valid</strong> (default):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>full</strong>, which is compatible with Caffe:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
<p>But <code class="docutils literal"><span class="pre">global_pool</span></code> is set to be true, then do a global pooling, namely reset
<code class="docutils literal"><span class="pre">kernel=(height,</span> <span class="pre">width)</span></code>.</p>
<p>Three pooling options are supported by <code class="docutils literal"><span class="pre">pool_type</span></code>:</p>
<ul class="simple">
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before
<em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth,
height, width)</em>.</p>
<p>Defined in src/operator/pooling.cc:L116</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the pooling operator.</li>
<li><strong>global_pool</strong> (<em>boolean, optional, default=False</em>) – Ignore kernel size, do global pooling based on current input feature map.</li>
<li><strong>cudnn_off</strong> (<em>boolean, optional, default=False</em>) – Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><strong>kernel</strong> (<em>Shape(tuple), required</em>) – pooling kernel size: (y, x) or (d, y, x)</li>
<li><strong>pool_type</strong> (<em>{'avg', 'max', 'sum'}, required</em>) – Pooling type to be applied.</li>
<li><strong>pooling_convention</strong> (<em>{'full', 'valid'},optional, default='valid'</em>) – Pooling convention to be applied.</li>
<li><strong>stride</strong> (<em>Shape(tuple), optional, default=()</em>) – stride: for pooling (y, x) or (d, y, x)</li>
<li><strong>pad</strong> (<em>Shape(tuple), optional, default=()</em>) – pad for pooling: (y, x) or (d, y, x)</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Pooling_v1">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Pooling_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>global_pool=_Null</em>, <em>kernel=_Null</em>, <em>pool_type=_Null</em>, <em>pooling_convention=_Null</em>, <em>stride=_Null</em>, <em>pad=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Pooling_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator is DEPRECATED.
Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><p class="first"><strong>data</strong>: <em>(batch_size, channel, height, width)</em></p>
</li>
<li><p class="first"><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>, with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">out_height</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">out_width</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<p>The definition of <em>f</em> depends on <code class="docutils literal"><span class="pre">pooling_convention</span></code>, which has two options:</p>
<ul>
<li><p class="first"><strong>valid</strong> (default):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>full</strong>, which is compatible with Caffe:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
<p>But <code class="docutils literal"><span class="pre">global_pool</span></code> is set to be true, then do a global pooling, namely reset
<code class="docutils literal"><span class="pre">kernel=(height,</span> <span class="pre">width)</span></code>.</p>
<p>Three pooling options are supported by <code class="docutils literal"><span class="pre">pool_type</span></code>:</p>
<ul class="simple">
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and
<em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before
<em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth,
height, width)</em>.</p>
<p>Defined in src/operator/pooling_v1.cc:L85</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the pooling operator.</li>
<li><strong>global_pool</strong> (<em>boolean, optional, default=False</em>) – Ignore kernel size, do global pooling based on current input feature map.</li>
<li><strong>kernel</strong> (<em>Shape(tuple), required</em>) – pooling kernel size: (y, x) or (d, y, x)</li>
<li><strong>pool_type</strong> (<em>{'avg', 'max', 'sum'}, required</em>) – Pooling type to be applied.</li>
<li><strong>pooling_convention</strong> (<em>{'full', 'valid'},optional, default='valid'</em>) – Pooling convention to be applied.</li>
<li><strong>stride</strong> (<em>Shape(tuple), optional, default=()</em>) – stride: for pooling (y, x) or (d, y, x)</li>
<li><strong>pad</strong> (<em>Shape(tuple), optional, default=()</em>) – pad for pooling: (y, x) or (d, y, x)</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.RNN">
<code class="descclassname">mxnet.symbol.</code><code class="descname">RNN</code><span class="sig-paren">(</span><em>data=None</em>, <em>parameters=None</em>, <em>state=None</em>, <em>state_cell=None</em>, <em>state_size=_Null</em>, <em>num_layers=_Null</em>, <em>bidirectional=_Null</em>, <em>mode=_Null</em>, <em>p=_Null</em>, <em>state_outputs=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.RNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a recurrent layer to input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to RNN</li>
<li><strong>parameters</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Vector of all RNN trainable parameters concatenated</li>
<li><strong>state</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – initial hidden state of the RNN</li>
<li><strong>state_cell</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – initial cell state for LSTM networks (only for LSTM)</li>
<li><strong>state_size</strong> (<em>int (non-negative), required</em>) – size of the state for each layer</li>
<li><strong>num_layers</strong> (<em>int (non-negative), required</em>) – number of stacked layers</li>
<li><strong>bidirectional</strong> (<em>boolean, optional, default=False</em>) – whether to use bidirectional recurrent layers</li>
<li><strong>mode</strong> (<em>{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}, required</em>) – the type of RNN to compute</li>
<li><strong>p</strong> (<em>float, optional, default=0</em>) – Dropout probability, fraction of the input that gets dropped out at training time</li>
<li><strong>state_outputs</strong> (<em>boolean, optional, default=False</em>) – Whether to have the states as symbol outputs.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.ROIPooling">
<code class="descclassname">mxnet.symbol.</code><code class="descname">ROIPooling</code><span class="sig-paren">(</span><em>data=None</em>, <em>rois=None</em>, <em>pooled_size=_Null</em>, <em>spatial_scale=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.ROIPooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs region of interest(ROI) pooling on the input array.</p>
<p>ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a <cite>Fast R-CNN</cite> network for object detection.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <cite>rois</cite>,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.</p>
<p>To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters <cite>rois</cite> and <cite>spatial_scale</cite>.</p>
<p>The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a <cite>pooled_size</cite> parameter. batch_size will change to the number of region
bounding boxes after <cite>ROIPooling</cite>.</p>
<p>The size of each region of interest doesn’t have to be perfectly divisible by
the number of pooling sections(<cite>pooled_size</cite>).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
       [  6.,   7.,   8.,   9.,  10.,  11.],
       [ 12.,  13.,  14.,  15.,  16.,  17.],
       [ 18.,  19.,  20.,  21.,  22.,  23.],
       [ 24.,  25.,  26.,  27.,  28.,  29.],
       [ 30.,  31.,  32.,  33.,  34.,  35.],
       [ 36.,  37.,  38.,  39.,  40.,  41.],
       [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

// region of interest i.e. bounding box coordinates.
y = [[0,0,0,4,4]]

// returns array of shape (2,2) according to the given roi with max pooling.
ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                  [ 26.,  28.]]]]

// region of interest is changed due to the change in `spacial_scale` parameter.
ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                  [ 19.,  21.]]]]
</pre></div>
</div>
<p>Defined in src/operator/roi_pooling.cc:L269</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array to the pooling operator,  a 4D Feature maps</li>
<li><strong>rois</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <cite>batch_index</cite> indicates the index of corresponding image in the input array</li>
<li><strong>pooled_size</strong> (<em>Shape(tuple), required</em>) – ROI pooling output shape (h,w)</li>
<li><strong>spatial_scale</strong> (<em>float, required</em>) – Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Reshape">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Reshape</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>reverse=_Null</em>, <em>target_shape=_Null</em>, <em>keep_highest=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes the input array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Reshape</span></code> is deprecated, use <code class="docutils literal"><span class="pre">reshape</span></code></p>
</div>
<p>Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4).The size of the new shape should be same as the size of the input array.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">0</span></code>  copy this dimension from the input to the output shape.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-1</span></code> infers the dimension of the output shape by using the remainder of the input dimensions
keeping the size of the new array same as that of the input array.
At most one dimension of shape can be -1.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
- input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
- input shape = (2,3,4), shape=(-1,), output shape = (24,)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-2</span></code> copy all/remainder of the input dimensions to the output shape.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
- input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
- input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-3</span></code> use the product of two consecutive dimensions of the input shape as the output dimension.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
- input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
- input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
- input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-4</span></code> split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
- input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
</pre></div>
</div>
</li>
</ul>
<p>If the argument <cite>reverse</cite> is set to 1, then the special values are inferred from right to left.</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
- with reverse=1, output shape will be (50,4).
</pre></div>
</div>
</div></blockquote>
<p>Defined in src/operator/tensor/matrix_op.cc:L88</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to reshape.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – The target shape</li>
<li><strong>reverse</strong> (<em>boolean, optional, default=False</em>) – If true then the special values are inferred from right to left</li>
<li><strong>target_shape</strong> (<em>Shape(tuple), optional, default=()</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</li>
<li><strong>keep_highest</strong> (<em>boolean, optional, default=False</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SVMOutput">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SVMOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>margin=_Null</em>, <em>regularization_coefficient=_Null</em>, <em>use_linear=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SVMOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes support vector machine based transformation of the input.</p>
<p>This tutorial demonstrates using SVM as output layer for classification instead of softmax:
<a class="reference external" href="https://github.com/dmlc/mxnet/tree/master/example/svm_mnist">https://github.com/dmlc/mxnet/tree/master/example/svm_mnist</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data for SVM transformation.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Class label for the input data.</li>
<li><strong>margin</strong> (<em>float, optional, default=1</em>) – The loss function penalizes outputs that lie outside this margin. Default margin is 1.</li>
<li><strong>regularization_coefficient</strong> (<em>float, optional, default=1</em>) – Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</li>
<li><strong>use_linear</strong> (<em>boolean, optional, default=False</em>) – Whether to use L1-SVM objective. L2-SVM objective is used by default.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SequenceLast">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SequenceLast</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SequenceLast" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the last element of a sequence.</p>
<p>This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences. <cite>sequence_length</cite> should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set <cite>use_sequence_length</cite> to <cite>True</cite>, otherwise each example in the batch is assumed
to have the max sequence length.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, you can also use <cite>take</cite> operator.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[  1.,   2.,   3.],
      [  4.,   5.,   6.],
      [  7.,   8.,   9.]],

     [[ 10.,   11.,   12.],
      [ 13.,   14.,   15.],
      [ 16.,   17.,   18.]],

     [[  19.,   20.,   21.],
      [  22.,   23.,   24.],
      [  25.,   26.,   27.]]]

// returns last sequence when sequence_length parameter is not used
SequenceLast(x) = [[  19.,   20.,   21.],
                   [  22.,   23.,   24.],
                   [  25.,   26.,   27.]]

// sequence_length y is used
SequenceLast(x, y=[1,1,1], use_sequence_length=True) =
         [[  1.,   2.,   3.],
          [  4.,   5.,   6.],
          [  7.,   8.,   9.]]

// sequence_length y is used
SequenceLast(x, y=[1,2,3], use_sequence_length=True) =
         [[  1.,    2.,   3.],
          [  13.,  14.,  15.],
          [  25.,  26.,  27.]]
</pre></div>
</div>
<p>Defined in src/operator/sequence_last.cc:L73</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean, optional, default=False</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SequenceMask">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SequenceMask</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>value=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SequenceMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all elements outside the sequence to a constant value.</p>
<p>This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences. <cite>sequence_length</cite>
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set <cite>use_sequence_length</cite> to <cite>True</cite>,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the <cite>identity</cite> operator.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[  1.,   2.,   3.],
      [  4.,   5.,   6.]],

     [[  7.,   8.,   9.],
      [ 10.,  11.,  12.]],

     [[ 13.,  14.,   15.],
      [ 16.,  17.,   18.]]]

// Batch 1
B1 = [[  1.,   2.,   3.],
      [  7.,   8.,   9.],
      [ 13.,  14.,  15.]]

// Batch 2
B2 = [[  4.,   5.,   6.],
      [ 10.,  11.,  12.],
      [ 16.,  17.,  18.]]

// works as identity operator when sequence_length parameter is not used
SequenceMask(x) = [[[  1.,   2.,   3.],
                    [  4.,   5.,   6.]],

                   [[  7.,   8.,   9.],
                    [ 10.,  11.,  12.]],

                   [[ 13.,  14.,   15.],
                    [ 16.,  17.,   18.]]]

// sequence_length [1,1] means 1 of each batch will be kept
// and other rows are masked with default mask value = 0
SequenceMask(x, y=[1,1], use_sequence_length=True) =
             [[[  1.,   2.,   3.],
               [  4.,   5.,   6.]],

              [[  0.,   0.,   0.],
               [  0.,   0.,   0.]],

              [[  0.,   0.,   0.],
               [  0.,   0.,   0.]]]

// sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
// and other rows are masked with value = 1
SequenceMask(x, y=[2,3], use_sequence_length=True, value=1) =
             [[[  1.,   2.,   3.],
               [  4.,   5.,   6.]],

              [[  7.,   8.,   9.],
               [  10.,  11.,  12.]],

              [[   1.,   1.,   1.],
               [  16.,  17.,  18.]]]
</pre></div>
</div>
<p>Defined in src/operator/sequence_mask.cc:L108</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean, optional, default=False</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>value</strong> (<em>float, optional, default=0</em>) – The value to be used as a mask.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SequenceReverse">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SequenceReverse</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SequenceReverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the elements of each sequence.</p>
<p>This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences.
<cite>sequence_length</cite> should be an input array of positive ints of dimension [batch_size].
To use this parameter, set <cite>use_sequence_length</cite> to <cite>True</cite>,
otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[  1.,   2.,   3.],
      [  4.,   5.,   6.]],

     [[  7.,   8.,   9.],
      [ 10.,  11.,  12.]],

     [[ 13.,  14.,   15.],
      [ 16.,  17.,   18.]]]

// Batch 1
B1 = [[  1.,   2.,   3.],
      [  7.,   8.,   9.],
      [ 13.,  14.,  15.]]

// Batch 2
B2 = [[  4.,   5.,   6.],
      [ 10.,  11.,  12.],
      [ 16.,  17.,  18.]]

// returns reverse sequence when sequence_length parameter is not used
SequenceReverse(x) = [[[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]],

                      [[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[  1.,   2.,   3.],
                       [  4.,   5.,   6.]]]

// sequence_length [2,2] means 2 rows of
// both batch B1 and B2 will be reversed.
SequenceReverse(x, y=[2,2], use_sequence_length=True) =
                  [[[  7.,   8.,   9.],
                    [ 10.,  11.,  12.]],

                   [[  1.,   2.,   3.],
                    [  4.,   5.,   6.]],

                   [[ 13.,  14.,   15.],
                    [ 16.,  17.,   18.]]]

// sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
// will be reversed.
SequenceReverse(x, y=[2,3], use_sequence_length=True) =
                 [[[  7.,   8.,   9.],
                   [ 16.,  17.,  18.]],

                  [[  1.,   2.,   3.],
                   [ 10.,  11.,  12.]],

                  [[ 13.,  14,   15.],
                   [  4.,   5.,   6.]]]
</pre></div>
</div>
<p>Defined in src/operator/sequence_reverse.cc:L94</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean, optional, default=False</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SliceChannel">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SliceChannel</code><span class="sig-paren">(</span><em>data=None</em>, <em>num_outputs=_Null</em>, <em>axis=_Null</em>, <em>squeeze_axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SliceChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits an array along a particular axis into multiple sub-arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">SliceChannel</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">split</span></code> instead.</p>
</div>
<p><strong>Note</strong> that <cite>num_outputs</cite> should evenly divide the length of the axis
along which to split the array.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x  = [[[ 1.]
       [ 2.]]
      [[ 3.]
       [ 4.]]
      [[ 5.]
       [ 6.]]]
x.shape = (3, 2, 1)

y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
y = [[[ 1.]]
     [[ 3.]]
     [[ 5.]]]

    [[[ 2.]]
     [[ 4.]]
     [[ 6.]]]

y[0].shape = (3, 1, 1)

z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
z = [[[ 1.]
      [ 2.]]]

    [[[ 3.]
      [ 4.]]]

    [[[ 5.]
      [ 6.]]]

z[0].shape = (1, 2, 1)
</pre></div>
</div>
<p><cite>squeeze_axis=1</cite> removes the axis with length 1 from the shapes of the output arrays.
<strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">1</span></code> removes axis with length 1 only
along the <cite>axis</cite> which it is split.
Also <cite>squeeze_axis</cite> can be set to true only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
z = [[ 1.]
     [ 2.]]

    [[ 3.]
     [ 4.]]

    [[ 5.]
     [ 6.]]
z[0].shape = (2 ,1 )
</pre></div>
</div>
<p>Defined in src/operator/slice_channel.cc:L88</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>num_outputs</strong> (<em>int, required</em>) – Number of splits. Note that this should evenly divide the length of the <cite>axis</cite>.</li>
<li><strong>axis</strong> (<em>int, optional, default='1'</em>) – Axis along which to split.</li>
<li><strong>squeeze_axis</strong> (<em>boolean, optional, default=False</em>) – If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">true</span></code> removes axis with length 1 only along the <cite>axis</cite> which it is split. Also <cite>squeeze_axis</cite> can be set to <code class="docutils literal"><span class="pre">true</span></code> only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.Softmax">
<code class="descclassname">mxnet.symbol.</code><code class="descname">Softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>grad_scale=_Null</em>, <em>ignore_label=_Null</em>, <em>multi_output=_Null</em>, <em>use_ignore=_Null</em>, <em>preserve_shape=_Null</em>, <em>normalization=_Null</em>, <em>out_grad=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.Softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use <cite>SoftmaxOutput</cite>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator has been renamed to <cite>SoftmaxOutput</cite>, which
computes the gradient of cross-entropy loss w.r.t softmax output.
To just compute softmax output, use the <cite>softmax</cite> operator.</p>
</div>
<p>Defined in src/operator/softmax_output.cc:L119</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Scales the gradient by a float factor.</li>
<li><strong>ignore_label</strong> (<em>float, optional, default=-1</em>) – The instances whose <cite>labels</cite> == <cite>ignore_label</cite> will be ignored during backward, if <cite>use_ignore</cite> is set to <code class="docutils literal"><span class="pre">true</span></code>).</li>
<li><strong>multi_output</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along axis <code class="docutils literal"><span class="pre">1</span></code>. This is applied when the shape of input array differs from the shape of label array.</li>
<li><strong>use_ignore</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the <cite>ignore_label</cite> value will not contribute to the backward gradient.</li>
<li><strong>preserve_shape</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along the last axis (<code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li><strong>normalization</strong> (<em>{'batch', 'null', 'valid'},optional, default='null'</em>) – Normalizes the gradient.</li>
<li><strong>out_grad</strong> (<em>boolean, optional, default=False</em>) – Multiplies gradient with output gradient element-wise.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SoftmaxActivation">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SoftmaxActivation</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SoftmaxActivation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies softmax activation to input. This is intended for internal layers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator has been deprecated, please use <cite>softmax</cite>.</p>
</div>
<p>If <cite>mode</cite> = <code class="docutils literal"><span class="pre">instance</span></code>, this operator will compute a softmax for each instance in the batch.
This is the default mode.</p>
<p>If <cite>mode</cite> = <code class="docutils literal"><span class="pre">channel</span></code>, this operator will compute a k-class softmax at each position
of each instance, where <cite>k</cite> = <code class="docutils literal"><span class="pre">num_channel</span></code>. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for <cite>fully convolutional network</cite>, <cite>image segmentation</cite>, etc.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">input_array</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">],</span>
<span class="gp">>>> </span>                           <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-.</span><span class="mi">4</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">softmax_act</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">SoftmaxActivation</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span>
<span class="gp">>>> </span><span class="k">print</span> <span class="n">softmax_act</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">[[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]</span>
<span class="go"> [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]</span>
</pre></div>
</div>
<p>Defined in src/operator/softmax_activation.cc:L48</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array to activation function.</li>
<li><strong>mode</strong> (<em>{'channel', 'instance'},optional, default='instance'</em>) – Specifies how to compute the softmax. If set to <code class="docutils literal"><span class="pre">instance</span></code>, it computes softmax for each instance. If set to <code class="docutils literal"><span class="pre">channel</span></code>, It computes cross channel softmax for each position of each instance.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SoftmaxOutput">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SoftmaxOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>ignore_label=_Null</em>, <em>multi_output=_Null</em>, <em>use_ignore=_Null</em>, <em>preserve_shape=_Null</em>, <em>normalization=_Null</em>, <em>out_grad=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SoftmaxOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li><p class="first">This operator computes the gradient in two steps.
The cross entropy loss does not actually need to be computed.</p>
<ul class="simple">
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
</ul>
</li>
<li><p class="first">The softmax function, cross entropy loss and gradient is given by:</p>
<ul>
<li><p class="first">Softmax Function:</p>
<div class="math">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
</li>
<li><p class="first">Cross Entropy Function:</p>
<div class="math">
\[\text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)\]</div>
</li>
<li><p class="first">The gradient of cross entropy loss w.r.t softmax output:</p>
<div class="math">
\[\text{gradient} = \text{output} - \text{label}\]</div>
</li>
</ul>
</li>
<li><p class="first">During forward propagation, the softmax function is computed for each instance in the input array.</p>
<p>For general <em>N</em>-D input arrays with shape <span class="math">\((d_1, d_2, ..., d_n)\)</span>. The size is
<span class="math">\(s=d_1 \cdot d_2 \cdot \cdot \cdot d_n\)</span>. We can use the parameters <cite>preserve_shape</cite>
and <cite>multi_output</cite> to specify the way to compute softmax:</p>
<ul class="simple">
<li>By default, <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">false</span></code>. This operator will reshape the input array
into a 2-D array with shape <span class="math">\((d_1, \frac{s}{d_1})\)</span> and then compute the softmax function for
each row in the reshaped array, and afterwards reshape it back to the original shape
<span class="math">\((d_1, d_2, ..., d_n)\)</span>.</li>
<li>If <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the last axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li>If <cite>multi_output</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the second axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">1</span></code>).</li>
</ul>
</li>
<li><p class="first">During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
The provided label can be a one-hot label array or a probability label array.</p>
<ul>
<li><p class="first">If the parameter <cite>use_ignore</cite> is <code class="docutils literal"><span class="pre">true</span></code>, <cite>ignore_label</cite> can specify input instances
with a particular label to be ignored during backward propagation. <strong>This has no effect when
softmax `output` has same shape as `label`</strong>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
label = [1,0,2,3]
ignore_label = 1
SoftmaxOutput(data=data, label = label,\
              multi_output=true, use_ignore=true,\
              ignore_label=ignore_label)
## forward softmax output
[[ 0.0320586   0.08714432  0.23688284  0.64391428]
 [ 0.25        0.25        0.25        0.25      ]
 [ 0.25        0.25        0.25        0.25      ]
 [ 0.25        0.25        0.25        0.25      ]]
## backward gradient output
[[ 0.    0.    0.    0.  ]
 [-0.75  0.25  0.25  0.25]
 [ 0.25  0.25 -0.75  0.25]
 [ 0.25  0.25  0.25 -0.75]]
## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
</pre></div>
</div>
</li>
<li><p class="first">The parameter <cite>grad_scale</cite> can be used to rescale the gradient, which is often used to
give each loss function different weights.</p>
</li>
<li><p class="first">This operator also supports various ways to normalize the gradient by <cite>normalization</cite>,
The <cite>normalization</cite> is applied if softmax output has different shape than the labels.
The <cite>normalization</cite> mode can be set to the followings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'null'</span></code>: do nothing.</li>
<li><code class="docutils literal"><span class="pre">'batch'</span></code>: divide the gradient by the batch size.</li>
<li><code class="docutils literal"><span class="pre">'valid'</span></code>: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L104</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Ground truth label.</li>
<li><strong>grad_scale</strong> (<em>float, optional, default=1</em>) – Scales the gradient by a float factor.</li>
<li><strong>ignore_label</strong> (<em>float, optional, default=-1</em>) – The instances whose <cite>labels</cite> == <cite>ignore_label</cite> will be ignored during backward, if <cite>use_ignore</cite> is set to <code class="docutils literal"><span class="pre">true</span></code>).</li>
<li><strong>multi_output</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along axis <code class="docutils literal"><span class="pre">1</span></code>. This is applied when the shape of input array differs from the shape of label array.</li>
<li><strong>use_ignore</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the <cite>ignore_label</cite> value will not contribute to the backward gradient.</li>
<li><strong>preserve_shape</strong> (<em>boolean, optional, default=False</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along the last axis (<code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li><strong>normalization</strong> (<em>{'batch', 'null', 'valid'},optional, default='null'</em>) – Normalizes the gradient.</li>
<li><strong>out_grad</strong> (<em>boolean, optional, default=False</em>) – Multiplies gradient with output gradient element-wise.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SpatialTransformer">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SpatialTransformer</code><span class="sig-paren">(</span><em>data=None</em>, <em>loc=None</em>, <em>target_shape=_Null</em>, <em>transform_type=_Null</em>, <em>sampler_type=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SpatialTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a spatial transformer to input feature map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to the SpatialTransformerOp.</li>
<li><strong>loc</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</li>
<li><strong>target_shape</strong> (<em>Shape(tuple), optional, default=(0,0)</em>) – output shape(h, w) of spatial transformer: (y, x)</li>
<li><strong>transform_type</strong> (<em>{'affine'}, required</em>) – transformation type</li>
<li><strong>sampler_type</strong> (<em>{'bilinear'}, required</em>) – sampling type</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.SwapAxis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">SwapAxis</code><span class="sig-paren">(</span><em>data=None</em>, <em>dim1=_Null</em>, <em>dim2=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.SwapAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchanges two axes of an array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span> x = [[1, 2, 3]])
 swapaxes(x, 0, 1) = [[ 1],
                      [ 2],
                      [ 3]]

 x = [[[ 0, 1],
       [ 2, 3]],
      [[ 4, 5],
       [ 6, 7]]]  // (2,2,2) array

swapaxes(x, 0, 2) = [[[ 0, 4],
                      [ 2, 6]],
                     [[ 1, 5],
                      [ 3, 7]]]
</pre></div>
</div>
<p>Defined in src/operator/swapaxis.cc:L51</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>dim1</strong> (<em>int (non-negative), optional, default=0</em>) – the first axis to be swapped.</li>
<li><strong>dim2</strong> (<em>int (non-negative), optional, default=0</em>) – the second axis to be swapped.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.UpSampling">
<code class="descclassname">mxnet.symbol.</code><code class="descname">UpSampling</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.UpSampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs nearest neighbor/bilinear up sampling to inputs.
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol[]</em>) – Array of tensors to upsample</li>
<li><strong>scale</strong> (<em>int (non-negative), required</em>) – Up sampling scale</li>
<li><strong>num_filter</strong> (<em>int (non-negative), optional, default=0</em>) – Input filter. Only used by bilinear sample_type.</li>
<li><strong>sample_type</strong> (<em>{'bilinear', 'nearest'}, required</em>) – upsampling method</li>
<li><strong>multi_input_mode</strong> (<em>{'concat', 'sum'},optional, default='concat'</em>) – How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</li>
<li><strong>workspace</strong> (<em>long (non-negative), optional, default=512</em>) – Tmp workspace for deconvolution (MB)</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.abs">
<code class="descclassname">mxnet.symbol.</code><code class="descname">abs</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise absolute value of the input.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L236</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.adam_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">adam_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mean=None</em>, <em>var=None</em>, <em>lr=_Null</em>, <em>beta1=_Null</em>, <em>beta2=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.adam_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).</p>
<div class="math">
\[\begin{split}g_t = \nabla J(W_{t-1})\\
m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">beta1</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta1</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">beta2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">w</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L126</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>mean</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Moving mean</li>
<li><strong>var</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Moving variance</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>beta1</strong> (<em>float, optional, default=0.9</em>) – The decay rate for the 1st moment estimates.</li>
<li><strong>beta2</strong> (<em>float, optional, default=0.999</em>) – The decay rate for the 2nd moment estimates.</li>
<li><strong>epsilon</strong> (<em>float, optional, default=1e-08</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.add_n">
<code class="descclassname">mxnet.symbol.</code><code class="descname">add_n</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.add_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all input arguments element-wise.</p>
<div class="math">
\[add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\]</div>
<p><code class="docutils literal"><span class="pre">add_n</span></code> is potentially more efficient than calling <code class="docutils literal"><span class="pre">add</span></code> by <cite>n</cite> times.</p>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L47
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>Symbol[]</em>) – Positional input arguments</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arccos">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arccos</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse cosine of the input array.</p>
<p>The input should be in range <cite>[-1, 1]</cite>.
The output is in the closed interval <span class="math">\([0, \pi]\)</span></p>
<div class="math">
\[arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L541</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arccosh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arccosh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.</p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L647</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arcsin">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arcsin</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse sine of the input array.</p>
<p>The input should be in the range <cite>[-1, 1]</cite>.
The output is in the closed interval of [<span class="math">\(-\pi/2\)</span>, <span class="math">\(\pi/2\)</span>].</p>
<div class="math">
\[arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L524</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arcsinh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arcsinh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.</p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L637</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arctan">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arctan</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse tangent of the input array.</p>
<p>The output is in the closed interval <span class="math">\([-\pi/2, \pi/2]\)</span></p>
<div class="math">
\[arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L557</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.arctanh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">arctanh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.</p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L657</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.argmax">
<code class="descclassname">mxnet.symbol.</code><code class="descname">argmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of the maximum values along an axis.</p>
<p>In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 0.,  1.,  2.],
     [ 3.,  4.,  5.]]

// argmax along axis 0
argmax(x, axis=0) = [ 1.,  1.,  1.]

// argmax along axis 1
argmax(x, axis=1) = [ 2.,  2.]

// argmax along axis 1 keeping same dims as an input array
argmax(x, axis=1, keepdims=True) = [[ 2.],
                                    [ 2.]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L33</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>int or None, optional, default='None'</em>) – The axis along which to perform the reduction. Negative values means indexing from right to left. <code class="docutils literal"><span class="pre">Requires</span> <span class="pre">axis</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">set</span> <span class="pre">as</span> <span class="pre">int,</span> <span class="pre">because</span> <span class="pre">global</span> <span class="pre">reduction</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">supported</span> <span class="pre">yet.</span></code></li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.argmax_channel">
<code class="descclassname">mxnet.symbol.</code><code class="descname">argmax_channel</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.argmax_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns argmax indices of each channel from the input array.</p>
<p>The result will be an NDArray of shape (num_channel,).</p>
<p>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="n">argmax_channel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L78</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.argmin">
<code class="descclassname">mxnet.symbol.</code><code class="descname">argmin</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of the minimum values along an axis.</p>
<p>In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 0.,  1.,  2.],
     [ 3.,  4.,  5.]]

// argmin along axis 0
argmin(x, axis=0) = [ 0.,  0.,  0.]

// argmin along axis 1
argmin(x, axis=1) = [ 0.,  0.]

// argmin along axis 1 keeping same dims as an input array
argmin(x, axis=1, keepdims=True) = [[ 0.],
                                    [ 0.]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L58</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>int or None, optional, default='None'</em>) – The axis along which to perform the reduction. Negative values means indexing from right to left. <code class="docutils literal"><span class="pre">Requires</span> <span class="pre">axis</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">set</span> <span class="pre">as</span> <span class="pre">int,</span> <span class="pre">because</span> <span class="pre">global</span> <span class="pre">reduction</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">supported</span> <span class="pre">yet.</span></code></li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.argsort">
<code class="descclassname">mxnet.symbol.</code><code class="descname">argsort</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>is_ascend=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an input array along the given axis.</p>
<p>This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 0.3,  0.2,  0.4],
     [ 0.1,  0.3,  0.2]]

// sort along axis -1
argsort(x) = [[ 1.,  0.,  2.],
              [ 0.,  2.,  1.]]

// sort along axis 0
argsort(x, axis=0) = [[ 1.,  0.,  1.]
                      [ 0.,  1.,  0.]]

// flatten and then sort
argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L157</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int or None, optional, default='-1'</em>) – Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><strong>is_ascend</strong> (<em>boolean, optional, default=True</em>) – Whether to sort in ascending or descending order.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.batch_dot">
<code class="descclassname">mxnet.symbol.</code><code class="descname">batch_dot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.batch_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Batchwise dot product.</p>
<p><code class="docutils literal"><span class="pre">batch_dot</span></code> is used to compute dot product of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> when <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> are data in batch, namely 3D arrays in shape of <cite>(batch_size, :, :)</cite>.</p>
<p>For example, given <code class="docutils literal"><span class="pre">x</span></code> with shape <cite>(batch_size, n, m)</cite> and <code class="docutils literal"><span class="pre">y</span></code> with shape
<cite>(batch_size, m, k)</cite>, the result array will have shape <cite>(batch_size, n, k)</cite>,
which is computed by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">batch_dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L412</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The second input</li>
<li><strong>transpose_a</strong> (<em>boolean, optional, default=False</em>) – If true then transpose the first input before dot.</li>
<li><strong>transpose_b</strong> (<em>boolean, optional, default=False</em>) – If true then transpose the second input before dot.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.batch_take">
<code class="descclassname">mxnet.symbol.</code><code class="descname">batch_take</code><span class="sig-paren">(</span><em>a=None</em>, <em>indices=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.batch_take" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes elements from a data batch.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>batch_take</cite> is deprecated. Use <cite>pick</cite> instead.</p>
</div>
<p>Given an input array of shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1)</span></code> and indices of shape <code class="docutils literal"><span class="pre">(i0,)</span></code>, the result will be
an output array of shape <code class="docutils literal"><span class="pre">(i0,)</span></code> with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 1.,  2.],
     [ 3.,  4.],
     [ 5.,  6.]]

// takes elements with specified indices
batch_take(x, [0,1,0]) = [ 1.  4.  5.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L172</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The index array</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_add">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_add</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><cite>broadcast_plus</cite> is an alias to the function <cite>broadcast_add</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>

<span class="n">broadcast_plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L32</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_axes">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_axes</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>size=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// given x of shape (1,2,1)
x = [[[ 1.],
      [ 2.]]]

// broadcast x on on axis 2
broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                      [ 2.,  2.,  2.]]]
// broadcast x on on axes 0 and 2
broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                              [ 2.,  2.,  2.]],
                                             [[ 1.,  1.,  1.],
                                              [ 2.,  2.,  2.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L168</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – The axes to perform the broadcasting.</li>
<li><strong>size</strong> (<em>Shape(tuple), optional, default=()</em>) – Target sizes of the broadcasting axes.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_axis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>size=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// given x of shape (1,2,1)
x = [[[ 1.],
      [ 2.]]]

// broadcast x on on axis 2
broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                      [ 2.,  2.,  2.]]]
// broadcast x on on axes 0 and 2
broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                              [ 2.,  2.,  2.]],
                                             [[ 1.,  1.,  1.],
                                              [ 2.,  2.,  2.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L168</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – The axes to perform the broadcasting.</li>
<li><strong>size</strong> (<em>Shape(tuple), optional, default=()</em>) – Target sizes of the broadcasting axes.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_div">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_div</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">]]</span>

<span class="n">broadcast_div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L137</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_equal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L27</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_greater">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_greater</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than</strong> (>) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L63</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_greater_equal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_greater_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than or equal to</strong> (>=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L81</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_hypot">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_hypot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_hypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hypotenuse of a right angled triangle, given its “legs”
with broadcasting.</p>
<p>It is equivalent to doing <span class="math">\(sqrt(x_1^2 + x_2^2)\)</span>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

<span class="n">broadcast_hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

<span class="n">broadcast_hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L137</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_lesser">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_lesser</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_lesser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than</strong> (<) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_lesser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L99</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_lesser_equal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_lesser_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_lesser_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than or equal to</strong> (<=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_lesser_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L117</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_maximum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_maximum</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise maxima.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L61</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_minimum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_minimum</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise minima.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L96</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_minus">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_minus</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><cite>broadcast_minus</cite> is an alias to the function <cite>broadcast_sub</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_mod">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_mod</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise modulo of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">]]</span>

<span class="n">broadcast_mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L170</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_mul">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_mul</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L104</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_not_equal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_not_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                             <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L45</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_plus">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_plus</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><cite>broadcast_plus</cite> is an alias to the function <cite>broadcast_add</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>

<span class="n">broadcast_plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L32</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_power">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_power</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L26</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_sub">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_sub</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><cite>broadcast_minus</cite> is an alias to the function <cite>broadcast_sub</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Second input to the function</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.broadcast_to">
<code class="descclassname">mxnet.symbol.</code><code class="descname">broadcast_to</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array to a new shape.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, <a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a> for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
                                        [ 1.,  2.,  3.]])
</pre></div>
</div>
<p>The dimension which you do not want to change can also be kept as <cite>0</cite> which means copy the original value.
So with <cite>shape=(2,0)</cite>, we will obtain the same result as in the above example.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L192</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – The shape of the desired array. We can set the dim to zero if it’s same as the original. E.g <cite>A = broadcast_to(B, shape=(10, 0, 0))</cite> has the same meaning as <cite>A = broadcast_axis(B, axis=0, size=10)</cite>.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.cast">
<code class="descclassname">mxnet.symbol.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>data=None</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts all elements of the input to a new type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Cast</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">cast</span></code> instead.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cast</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mf">1e20</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="mf">11.09375</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint8'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">253</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L175</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input.</li>
<li><strong>dtype</strong> (<em>{'float16', 'float32', 'float64', 'int32', 'uint8'}, required</em>) – Output data type.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.ceil">
<code class="descclassname">mxnet.symbol.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i >= x.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ceil</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L295</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.choose_element_0index">
<code class="descclassname">mxnet.symbol.</code><code class="descname">choose_element_0index</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.choose_element_0index" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="ndarray.html#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Left operand to the function.</li>
<li><strong>rhs</strong> (<a class="reference internal" href="ndarray.html#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Right operand to the function.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.clip">
<code class="descclassname">mxnet.symbol.</code><code class="descname">clip</code><span class="sig-paren">(</span><em>data=None</em>, <em>a_min=_Null</em>, <em>a_max=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips (limits) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to the interval edges.
Clipping <code class="docutils literal"><span class="pre">x</span></code> between <cite>a_min</cite> and <cite>a_x</cite> would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>clip(x, a_min, a_max) = max(min(x, a_max), a_min))
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L457</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>a_min</strong> (<em>float, required</em>) – Minimum value</li>
<li><strong>a_max</strong> (<em>float, required</em>) – Maximum value</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.concat">
<code class="descclassname">mxnet.symbol.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins input arrays along a given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Concat</cite> is deprecated. Use <cite>concat</cite> instead.</p>
</div>
<p>The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[1,1],[2,2]]
y = [[3,3],[4,4],[5,5]]
z = [[6,6], [7,7],[8,8]]

concat(x,y,z,dim=0) = [[ 1.,  1.],
                       [ 2.,  2.],
                       [ 3.,  3.],
                       [ 4.,  4.],
                       [ 5.,  5.],
                       [ 6.,  6.],
                       [ 7.,  7.],
                       [ 8.,  8.]]

Note that you cannot concat x,y,z along dimension 1 since dimension
0 is not the same for all the input arrays.

concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                      [ 4.,  4.,  7.,  7.],
                      [ 5.,  5.,  8.,  8.]]
</pre></div>
</div>
<p>Defined in src/operator/concat.cc:L80
This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol[]</em>) – List of arrays to concatenate</li>
<li><strong>dim</strong> (<em>int, optional, default='1'</em>) – the dimension to be concated.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.cos">
<code class="descclassname">mxnet.symbol.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise cosine of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L491</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.cosh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">cosh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic cosine  of the input array, computed element-wise.</p>
<div class="math">
\[cosh(x) = 0.5\times(exp(x) + exp(-x))\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L613</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.crop">
<code class="descclassname">mxnet.symbol.</code><code class="descname">crop</code><span class="sig-paren">(</span><em>data=None</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a contiguous region of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">crop</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">slice</span></code> instead.</p>
</div>
<p>This function returns a sliced continuous region of the array between the indices given
by <cite>begin</cite> and <cite>end</cite>.</p>
<p>For an input array of <cite>n</cite> dimensions, slice operation with <code class="docutils literal"><span class="pre">begin=(b_0,</span> <span class="pre">b_1...b_n-1)</span></code> indices
and <code class="docutils literal"><span class="pre">end=(e_1,</span> <span class="pre">e_2,</span> <span class="pre">...</span> <span class="pre">e_n)</span></code> indices will result in an array with the shape
<code class="docutils literal"><span class="pre">(e_1-b_0,</span> <span class="pre">...,</span> <span class="pre">e_n-b_n-1)</span></code>.</p>
<p>The resulting array’s <em>k</em>-th dimension contains elements
from the <em>k</em>-th dimension of the input array with the open range <code class="docutils literal"><span class="pre">[b_k,</span> <span class="pre">e_k)</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L257</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>begin</strong> (<em>Shape(tuple), required</em>) – starting indices for the slice operation, supports negative indices.</li>
<li><strong>end</strong> (<em>Shape(tuple), required</em>) – ending indices for the slice operation, supports negative indices.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.degrees">
<code class="descclassname">mxnet.symbol.</code><code class="descname">degrees</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each element of the input array from radians to degrees.</p>
<div class="math">
\[degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L571</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.dot">
<code class="descclassname">mxnet.symbol.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays.</p>
<p><code class="docutils literal"><span class="pre">dot</span></code>‘s behavior depends on the input array dimensions:</p>
<ul>
<li><p class="first">1-D arrays: inner product of vectors</p>
</li>
<li><p class="first">2-D arrays: matrix multiplication</p>
</li>
<li><p class="first">N-D arrays: a sum product over the last axis of the first input and the first
axis of the second input</p>
<p>For example, given 3-D <code class="docutils literal"><span class="pre">x</span></code> with shape <cite>(n,m,k)</cite> and <code class="docutils literal"><span class="pre">y</span></code> with shape <cite>(k,r,s)</cite>, the
result array will have shape <cite>(n,m,r,s)</cite>. It is computed by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span><span class="o">*</span><span class="n">y</span><span class="p">[:,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L376</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The second input</li>
<li><strong>transpose_a</strong> (<em>boolean, optional, default=False</em>) – If true then transpose the first input before dot.</li>
<li><strong>transpose_b</strong> (<em>boolean, optional, default=False</em>) – If true then transpose the second input before dot.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.elemwise_add">
<code class="descclassname">mxnet.symbol.</code><code class="descname">elemwise_add</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.elemwise_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds arguments element-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – second input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.exp">
<code class="descclassname">mxnet.symbol.</code><code class="descname">exp</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise exponential value of the input.</p>
<div class="math">
\[exp(x) = e^x \approx 2.718^x\]</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">exp</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.707</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L402</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.expand_dims">
<code class="descclassname">mxnet.symbol.</code><code class="descname">expand_dims</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a new axis of size 1 into the array shape</p>
<p>For example, given <code class="docutils literal"><span class="pre">x</span></code> with shape <code class="docutils literal"><span class="pre">(2,3,4)</span></code>, then <code class="docutils literal"><span class="pre">expand_dims(x,</span> <span class="pre">axis=1)</span></code>
will return a new array with shape <code class="docutils literal"><span class="pre">(2,1,3,4)</span></code>.</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L213</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>axis</strong> (<em>int, required</em>) – Position where new axis is to be inserted. Suppose that the input <cite>NDArray</cite>‘s dimension is <cite>ndim</cite>, the range of the inserted axis is <cite>[-ndim, ndim]</cite></li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.expm1">
<code class="descclassname">mxnet.symbol.</code><code class="descname">expm1</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> computed element-wise on the input.</p>
<p>This function provides greater precision than <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for small values of <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L475</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.fill_element_0index">
<code class="descclassname">mxnet.symbol.</code><code class="descname">fill_element_0index</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>mhs=None</em>, <em>rhs=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.fill_element_0index" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="ndarray.html#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Left operand to the function.</li>
<li><strong>mhs</strong> (<a class="reference internal" href="ndarray.html#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Middle operand to the function.</li>
<li><strong>rhs</strong> (<a class="reference internal" href="ndarray.html#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Right operand to the function.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.fix">
<code class="descclassname">mxnet.symbol.</code><code class="descname">fix</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer towards zero of the input.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fix</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L333</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.flatten">
<code class="descclassname">mxnet.symbol.</code><code class="descname">flatten</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Flatten</cite> is deprecated. Use <cite>flatten</cite> instead.</p>
</div>
<p>For an input array with shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>, <cite>flatten</cite> operation reshapes
the input array into an output array of shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">],</span>
<span class="p">[</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">]],</span>

<span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L132</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.flip">
<code class="descclassname">mxnet.symbol.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">9.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L601</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data array</li>
<li><strong>axis</strong> (<em>Shape(tuple), required</em>) – The axis which to reverse elements.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.floor">
<code class="descclassname">mxnet.symbol.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i <= x.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">floor</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L308</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.gamma">
<code class="descclassname">mxnet.symbol.</code><code class="descname">gamma</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gamma function (extension of the factorial function to the reals) , computed element-wise on the input array.</p>
<p>From:src/operator/tensor/elemwise_unary_op.cc:667</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.gammaln">
<code class="descclassname">mxnet.symbol.</code><code class="descname">gammaln</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.gammaln" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise log of the absolute value of the gamma function of the input.</p>
<p>From:src/operator/tensor/elemwise_unary_op.cc:677</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.identity">
<code class="descclassname">mxnet.symbol.</code><code class="descname">identity</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise_unary_op.cc:49</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_gemm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_gemm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>C=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>alpha=_Null</em>, <em>beta=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_gemm" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs general matrix multiplication and accumulation.
Input are three tensors <em>A</em>, <em>B</em>, <em>C</em> each of dimension <em>n >= 2</em> and each
having the same shape on the leading <em>n-2</em> dimensions. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub>, <em>B</em><sub>i</sub>, <em>C</em><sub>i</sub> be the matrices given by the last <em>2</em> dimensions.
The operator performs the BLAS3 function <em>gemm</em></p>
<blockquote>
<div><em>out</em><sub>i</sub> = <em>alpha</em> * <em>op</em>(<em>A</em><sub>i</sub>) * <em>op</em>(<em>B</em><sub>i</sub>) + <em>beta</em> * <em>C</em><sub>i</sub></div></blockquote>
<p>on all such triples of matrices. Here <em>alpha</em> and <em>beta</em> are scalar operator parameters and <em>op()</em>
is either the identity or the matrix transposition.</p>
<p>In case of <em>n=2</em>, a single <em>gemm</em> function is performed on the matrices <em>A</em>, <em>B</em>, <em>C</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix multiply-add
A = [[1.0, 1.0], [1.0, 1.0]]
B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
linalg_gemm(A, B, C, transpose_b = 1, alpha = 2.0 , beta = 10.0)
        = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]

// Batch matrix multiply-add
A = [[[1.0, 1.0]], [[0.1, 0.1]]]
B = [[[1.0, 1.0]], [[0.1, 0.1]]]
C = [[[10.0]], [[0.01]]]
linalg_gemm(A, B, C, transpose_b = 1, alpha = 2.0 , beta = 10.0)
        = [[[104.0]], [[0.14]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L48</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices</li>
<li><strong>C</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices</li>
<li><strong>transpose_a</strong> (<em>boolean, optional, default=False</em>) – Multiply with transposed of first input (A).</li>
<li><strong>transpose_b</strong> (<em>boolean, optional, default=False</em>) – Multiply with transposed of second input (B).</li>
<li><strong>alpha</strong> (<em>double, optional, default=1</em>) – Scalar factor multiplied with A*B.</li>
<li><strong>beta</strong> (<em>double, optional, default=1</em>) – Scalar factor multiplied with C.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_gemm2">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_gemm2</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>alpha=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_gemm2" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs general matrix multiplication.
Input are two tensors <em>A</em>, <em>B</em> each of dimension <em>n >= 2</em> and each
having the same shape on the leading <em>n-2</em> dimensions. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub>, <em>B</em><sub>i</sub> be the matrices given by the last <em>2</em> dimensions.
The operator performs the BLAS3 function <em>gemm</em> (restricted to two arguments)</p>
<blockquote>
<div><em>out</em><sub>i</sub> = <em>alpha</em> * <em>op</em>(<em>A</em><sub>i</sub>) * <em>op</em>(<em>B</em><sub>i</sub>)</div></blockquote>
<p>on all such pairs of matrices. Here <em>alpha</em> is a scalar operator parameter and <em>op()</em> is either
the identity or the matrix transposition.</p>
<p>In case of <em>n=2</em>, a single <em>gemm</em> function is performed on the matrices <em>A</em>, <em>B</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix multiply
A = [[1.0, 1.0], [1.0, 1.0]]
B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
linalg_gemm2(A, B, transpose_b = 1, alpha = 2.0)
         = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]

// Batch matrix multiply
A = [[[1.0, 1.0]], [[0.1, 0.1]]]
B = [[[1.0, 1.0]], [[0.1, 0.1]]]
linalg_gemm2(A, B, transpose_b = 1, alpha = 2.0 )
        = [[[4.0]], [[0.04 ]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L106</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices</li>
<li><strong>transpose_a</strong> (<em>boolean, optional, default=False</em>) – Multiply with transposed of first input (A).</li>
<li><strong>transpose_b</strong> (<em>boolean, optional, default=False</em>) – Multiply with transposed of second input (B).</li>
<li><strong>alpha</strong> (<em>double, optional, default=1</em>) – Scalar factor multiplied with A*B.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_potrf">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_potrf</code><span class="sig-paren">(</span><em>A=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_potrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub> be the matrix given by the last <em>2</em> dimensions.
The operator performs the Cholesky factorization (LAPACK function <em>potrf</em>)
on each <em>A</em><sub>i</sub>,
i.e. it computes a lower triangular matrix <em>U</em><sub>i</sub> such that</p>
<blockquote>
<div><em>A</em><sub>i</sub> = <em>U</em><sub>i</sub> * <em>U</em><sub>i</sub><sup>T</sup></div></blockquote>
<p>for all such matrices. The matrices <em>A</em><sub>i</sub> must be all symmetric and positive-definite.
The resulting matrices <em>U</em><sub>i</sub> will contain zeros in the upper triangle
apart from the diagonal.</p>
<p>In case of <em>n=2</em>, a single Cholesky factorization is performed on the matrix <em>A</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix factorization
A = [[4.0, 1.0], [1.0, 4.25]]
linalg_potrf(A) = [[2.0, 0], [0.5, 2.0]]

// Batch matrix factorization
A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
linalg_potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L159</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of input matrices to be decomposed</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_potri">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_potri</code><span class="sig-paren">(</span><em>A=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_potri" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs matrix inversion from a Cholesky factorization.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub> be the matrix given by the last <em>2</em> dimensions.
The operator assumes that each <em>A</em><sub>i</sub> is the Cholesky factorization of some symmetric
positive-definite matrix <em>B</em><sub>i</sub> given as a lower triangular matrix
(so <em>A</em> is the output of a prior call to operator <em>linalg_potrf</em>). The operator computes the
inverse of each <em>B</em><sub>i</sub> from this decomposition, i.e</p>
<blockquote>
<div><em>out</em><sub>i</sub> = <em>B</em><sub>i</sub><sup>-1</sup></div></blockquote>
<p>for all such matrices.</p>
<p>In case of <em>n=2</em>, the operation is performed on the matrix <em>A</em> itself.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix inverse
A = [[2.0, 0], [0.5, 2.0]]
linalg_potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]

// Batch matrix inverse
A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
linalg_potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
               [[0.06641, -0.01562], [-0.01562, 0,0625]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L211</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_sumlogdiag">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_sumlogdiag</code><span class="sig-paren">(</span><em>A=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_sumlogdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of the logarithms of all diagonal elements in a matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub> be the matrix given by the last <em>2</em> dimensions.
The operator performs a reduction of each such matrix to a scalar by summing up the logarithms
of all diagonal elements. All matrices must be square and all diagonal elements must be positive.</p>
<p>In case of <em>n=2</em>, <em>A</em> represents a single matrix on which the reduction will be performed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix reduction
A = [[1.0, 1.0], [1.0, 7.0]]
linalg_sumlogdiag(A) = [1.9459]

// Batch matrix reduction
A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
linalg_sumlogdiag(A) = [1.9459, 3.9318]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L379</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of square matrices</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_trmm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_trmm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose=_Null</em>, <em>rightside=_Null</em>, <em>alpha=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs multiplication with a triangular matrix.
Input are two tensors <em>A</em>, <em>B</em> each of dimension <em>n >= 2</em> and each
having the same shape on the leading <em>n-2</em> dimensions. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub>, <em>B</em><sub>i</sub> be the matrices given by the last <em>2</em> dimensions.
The operator performs the BLAS3 function <em>trmm</em></p>
<blockquote>
<div><em>out</em><sub>i</sub> = <em>alpha</em> * <em>op</em>(<em>A</em><sub>i</sub>) * <em>B</em><sub>i</sub></div></blockquote>
<p>or</p>
<blockquote>
<div><em>out</em><sub>i</sub> = <em>alpha</em> * <em>B</em><sub>i</sub> * <em>op</em>(<em>A</em><sub>i</sub>)</div></blockquote>
<p>on all such pairs of matrices. Here <em>alpha</em> is a scalar operator parameter,  <em>op()</em> is either
the identity or the matrix transposition (depending on the parameter <em>transpose</em>) and the
order of matrix multiplication depends on the parameter <em>rightside</em>.
All matrices <em>A</em><sub>i</sub> must be lower triangular.</p>
<p>In case of <em>n=2</em>, a single <em>trmm</em> function is performed on the matrices <em>A</em>, <em>B</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix multiply
A = [[1.0, 0], [1.0, 1.0]]
B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
linalg_trmm(A, B, alpha = 2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]

// Batch matrix multiply
A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
linalg_trmm(A, B, alpha = 2.0 ) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
                               [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L268</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of matrices</li>
<li><strong>transpose</strong> (<em>boolean, optional, default=False</em>) – Use transposed of the triangular matrix</li>
<li><strong>rightside</strong> (<em>boolean, optional, default=False</em>) – Multiply triangular matrix from the right to non-triangular one.</li>
<li><strong>alpha</strong> (<em>double, optional, default=1</em>) – Scalar factor to be applied to the result.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.linalg_trsm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">linalg_trsm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose=_Null</em>, <em>rightside=_Null</em>, <em>alpha=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.linalg_trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves matrix equations involving a triangular matrix.
Input are two tensors <em>A</em>, <em>B</em> each of dimension <em>n >= 2</em> and each
having the same shape on the leading <em>n-2</em> dimensions. For every <em>n-2</em> dimensional index <em>i</em> let
<em>A</em><sub>i</sub>, <em>B</em><sub>i</sub> be the matrices given by the last <em>2</em> dimensions.
The operator performs the BLAS3 function <em>trsm</em>, i.e. it solves the equation</p>
<blockquote>
<div><em>op</em>(<em>A</em><sub>i</sub>) * <em>X</em><sub>i</sub> = <em>alpha</em> * <em>B</em><sub>i</sub></div></blockquote>
<p>or</p>
<blockquote>
<div><em>X</em><sub>i</sub> * <em>op</em>(<em>A</em><sub>i</sub>) = <em>alpha</em> * <em>B</em><sub>i</sub></div></blockquote>
<p>on all such pairs of matrices. Here <em>alpha</em> is a scalar operator parameter,  <em>op()</em> is either
the identity or the matrix transposition (depending on the parameter <em>transpose</em>) and the
order of multiplication on the left depends on the parameter <em>rightside</em>.
All matrices <em>A</em><sub>i</sub> must be lower triangular.</p>
<p>In case of <em>n=2</em>, a single <em>trsm</em> function is performed on the matrices <em>A</em>, <em>B</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator does only support float32 and float64 data types and provides
proper backward gradients.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>// Single matrix solve
A = [[1.0, 0], [1.0, 1.0]]
B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
linalg_trsm(A, B, alpha = 0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]

// Batch matrix solve
A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
     [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
linalg_trsm(A, B, alpha = 0.5 ) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
                               [[2.0, 2.0, 2.0 ], [2.0, 2.0, 2.0]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L331</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Tensor of matrices</li>
<li><strong>transpose</strong> (<em>boolean, optional, default=False</em>) – Use transposed of the triangular matrix</li>
<li><strong>rightside</strong> (<em>boolean, optional, default=False</em>) – Multiply triangular matrix from the right to non-triangular one.</li>
<li><strong>alpha</strong> (<em>double, optional, default=1</em>) – Scalar factor to be applied to the result.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.log">
<code class="descclassname">mxnet.symbol.</code><code class="descname">log</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that <code class="docutils literal"><span class="pre">log(exp(x))</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L412</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.log10">
<code class="descclassname">mxnet.symbol.</code><code class="descname">log10</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p><code class="docutils literal"><span class="pre">10**log10(x)</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L422</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.log1p">
<code class="descclassname">mxnet.symbol.</code><code class="descname">log1p</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code> value of the input.</p>
<p>This function is more accurate than <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>  for small <code class="docutils literal"><span class="pre">x</span></code> so that
<span class="math">\(1+x\approx 1\)</span></p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L462</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.log2">
<code class="descclassname">mxnet.symbol.</code><code class="descname">log2</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p><code class="docutils literal"><span class="pre">2**log2(x)</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L432</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.log_softmax">
<code class="descclassname">mxnet.symbol.</code><code class="descname">log_softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.log_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</span>

<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">],[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-0.34115392, -0.69314718, -1.24115396],</span>
<span class="go">       [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>axis</strong> (<em>int, optional, default='-1'</em>) – The axis along which to compute softmax.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.make_loss">
<code class="descclassname">mxnet.symbol.</code><code class="descname">make_loss</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.make_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops gradient computation.
.. note:: <code class="docutils literal"><span class="pre">make_loss</span></code> is deprecated, use <code class="docutils literal"><span class="pre">MakeLoss</span></code>.</p>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L110</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.max">
<code class="descclassname">mxnet.symbol.</code><code class="descname">max</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L121</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.max_axis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">max_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.max_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L121</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.mean">
<code class="descclassname">mxnet.symbol.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L64</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.min">
<code class="descclassname">mxnet.symbol.</code><code class="descname">min</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L135</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.min_axis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">min_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.min_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L135</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.mp_sgd_mom_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">mp_sgd_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>weight32=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.mp_sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updater function for multi-precision sgd optimizer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Momentum</li>
<li><strong>weight32</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight32</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float, optional, default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.mp_sgd_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">mp_sgd_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>weight32=None</em>, <em>lr=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.mp_sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updater function for multi-precision sgd optimizer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – gradient</li>
<li><strong>weight32</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight32</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.nanprod">
<code class="descclassname">mxnet.symbol.</code><code class="descname">nanprod</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the product of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as one.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L107</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.nansum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">nansum</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as zero.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.negative">
<code class="descclassname">mxnet.symbol.</code><code class="descname">negative</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical negative of the argument, element-wise.</p>
<p>From:src/operator/tensor/elemwise_unary_op.cc:206</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.norm">
<code class="descclassname">mxnet.symbol.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the input array and then computes the l2 norm.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.47722578</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L218</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.normal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">normal</code><span class="sig-paren">(</span><em>loc=_Null</em>, <em>scale=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a normal (Gaussian) distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">normal</span></code> is deprecated.</p>
</div>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.89171135</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.16881478</span><span class="p">],</span>
                                              <span class="p">[</span><span class="o">-</span><span class="mf">1.23474145</span><span class="p">,</span>  <span class="mf">1.55807114</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L62</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loc</strong> (<em>float, optional, default=0</em>) – Mean of the distribution.</li>
<li><strong>scale</strong> (<em>float, optional, default=1</em>) – Standard deviation of the distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.one_hot">
<code class="descclassname">mxnet.symbol.</code><code class="descname">one_hot</code><span class="sig-paren">(</span><em>indices=None</em>, <em>depth=_Null</em>, <em>on_value=_Null</em>, <em>off_value=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.one_hot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a one-hot array.</p>
<p>The locations represented by <cite>indices</cite> take value <cite>on_value</cite>, while all
other locations take value <cite>off_value</cite>.</p>
<p><cite>one_hot</cite> operation with <cite>indices</cite> of shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1)</span></code> and <cite>depth</cite>  of <code class="docutils literal"><span class="pre">d</span></code> would result
in an output array of shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1,</span> <span class="pre">d)</span></code> with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">off_value</span>
<span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_value</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
                         [ 1.  0.  0.]
                         [ 0.  0.  1.]
                         [ 1.  0.  0.]]

one_hot([1,0,2,0], 3, on_value=8, off_value=1,
        dtype='int32') = [[1 8 1]
                          [8 1 1]
                          [1 1 8]
                          [8 1 1]]

one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
                                    [ 1.  0.  0.]]

                                   [[ 0.  1.  0.]
                                    [ 1.  0.  0.]]

                                   [[ 0.  0.  1.]
                                    [ 1.  0.  0.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L218</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – array of locations where to set on_value</li>
<li><strong>depth</strong> (<em>int, required</em>) – Depth of the one hot dimension.</li>
<li><strong>on_value</strong> (<em>double, optional, default=1</em>) – The value assigned to the locations represented by indices.</li>
<li><strong>off_value</strong> (<em>double, optional, default=0</em>) – The value assigned to the locations not represented by indices.</li>
<li><strong>dtype</strong> (<em>{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</em>) – DType of the output</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.ones_like">
<code class="descclassname">mxnet.symbol.</code><code class="descname">ones_like</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type
as the input array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.pad">
<code class="descclassname">mxnet.symbol.</code><code class="descname">pad</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>pad_width=_Null</em>, <em>constant_value=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an input array with a constant or edge values of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Pad</cite> is deprecated. Use <cite>pad</cite> instead.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Current implementation only supports 4D and 5D input arrays with padding applied
only on axes 1, 2 and 3. Expects axes 4 and 5 in <cite>pad_width</cite> to be zero.</p>
</div>
<p>This operation pads an input array with either a <cite>constant_value</cite> or edge values
along each axis of the input array. The amount of padding is specified by <cite>pad_width</cite>.</p>
<p><cite>pad_width</cite> is a tuple of integer padding widths for each axis of the format
<code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. The <cite>pad_width</cite> should be of length <code class="docutils literal"><span class="pre">2*N</span></code>
where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.</p>
<p>For dimension <code class="docutils literal"><span class="pre">N</span></code> of the input array, <code class="docutils literal"><span class="pre">before_N</span></code> and <code class="docutils literal"><span class="pre">after_N</span></code> indicates how many values
to add before and after the elements of the array along dimension <code class="docutils literal"><span class="pre">N</span></code>.
The widths of the higher two dimensions <code class="docutils literal"><span class="pre">before_1</span></code>, <code class="docutils literal"><span class="pre">after_1</span></code>, <code class="docutils literal"><span class="pre">before_2</span></code>,
<code class="docutils literal"><span class="pre">after_2</span></code> must be 0.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[[[  1.   2.   3.]
       [  4.   5.   6.]]

      [[  7.   8.   9.]
       [ 10.  11.  12.]]]


     [[[ 11.  12.  13.]
       [ 14.  15.  16.]]

      [[ 17.  18.  19.]
       [ 20.  21.  22.]]]]

pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

      [[[[  1.   1.   2.   3.   3.]
         [  1.   1.   2.   3.   3.]
         [  4.   4.   5.   6.   6.]
         [  4.   4.   5.   6.   6.]]

        [[  7.   7.   8.   9.   9.]
         [  7.   7.   8.   9.   9.]
         [ 10.  10.  11.  12.  12.]
         [ 10.  10.  11.  12.  12.]]]


       [[[ 11.  11.  12.  13.  13.]
         [ 11.  11.  12.  13.  13.]
         [ 14.  14.  15.  16.  16.]
         [ 14.  14.  15.  16.  16.]]

        [[ 17.  17.  18.  19.  19.]
         [ 17.  17.  18.  19.  19.]
         [ 20.  20.  21.  22.  22.]
         [ 20.  20.  21.  22.  22.]]]]

pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

      [[[[  0.   0.   0.   0.   0.]
         [  0.   1.   2.   3.   0.]
         [  0.   4.   5.   6.   0.]
         [  0.   0.   0.   0.   0.]]

        [[  0.   0.   0.   0.   0.]
         [  0.   7.   8.   9.   0.]
         [  0.  10.  11.  12.   0.]
         [  0.   0.   0.   0.   0.]]]


       [[[  0.   0.   0.   0.   0.]
         [  0.  11.  12.  13.   0.]
         [  0.  14.  15.  16.   0.]
         [  0.   0.   0.   0.   0.]]

        [[  0.   0.   0.   0.   0.]
         [  0.  17.  18.  19.   0.]
         [  0.  20.  21.  22.   0.]
         [  0.   0.   0.   0.   0.]]]]
</pre></div>
</div>
<p>Defined in src/operator/pad.cc:L747</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – An n-dimensional input array.</li>
<li><strong>mode</strong> (<em>{'constant', 'edge', 'reflect'}, required</em>) – Padding type to use. “constant” pads with <cite>constant_value</cite> “edge” pads using the edge values of the input array “reflect” pads by reflecting values with respect to the edges.</li>
<li><strong>pad_width</strong> (<em>Shape(tuple), required</em>) – Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. It should be of length <code class="docutils literal"><span class="pre">2*N</span></code> where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><strong>constant_value</strong> (<em>double, optional, default=0</em>) – The value used for padding when <cite>mode</cite> is “constant”.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.pick">
<code class="descclassname">mxnet.symbol.</code><code class="descname">pick</code><span class="sig-paren">(</span><em>data=None</em>, <em>index=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1)</span></code> and indices of shape <code class="docutils literal"><span class="pre">(i0,)</span></code>, the result will be
an output array of shape <code class="docutils literal"><span class="pre">(i0,)</span></code> with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre></div>
</div>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the <cite>clip</cite> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 1.,  2.],
     [ 3.,  4.],
     [ 5.,  6.]]

// picks elements with specified indices along axis 0
pick(x, y=[0,1], 0) = [ 1.,  4.]

// picks elements with specified indices along axis 1
pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

y = [[ 1.],
     [ 0.],
     [ 2.]]

// picks elements with specified indices along axis 1 and dims are maintained
pick(x,y, 1, keepdims=True) = [[ 2.],
                               [ 3.],
                               [ 6.]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L126</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>index</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The index array</li>
<li><strong>axis</strong> (<em>int or None, optional, default='None'</em>) – The axis along which to perform the reduction. Negative values means indexing from right to left. <code class="docutils literal"><span class="pre">Requires</span> <span class="pre">axis</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">set</span> <span class="pre">as</span> <span class="pre">int,</span> <span class="pre">because</span> <span class="pre">global</span> <span class="pre">reduction</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">supported</span> <span class="pre">yet.</span></code></li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.prod">
<code class="descclassname">mxnet.symbol.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the product of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L77</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.radians">
<code class="descclassname">mxnet.symbol.</code><code class="descname">radians</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each element of the input array from degrees to radians.</p>
<div class="math">
\[radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L585</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_exponential">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_exponential</code><span class="sig-paren">(</span><em>lam=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_exponential</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.0097189</span> <span class="p">,</span>  <span class="mf">0.08999364</span><span class="p">],</span>
                                          <span class="p">[</span> <span class="mf">0.04146638</span><span class="p">,</span>  <span class="mf">0.31715935</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L88</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<em>float, optional, default=1</em>) – Lambda parameter (rate) of the exponential distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_gamma">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_gamma</code><span class="sig-paren">(</span><em>alpha=_Null</em>, <em>beta=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_gamma</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">7.10486984</span><span class="p">,</span>  <span class="mf">3.37695289</span><span class="p">],</span>
                                                <span class="p">[</span> <span class="mf">3.91697288</span><span class="p">,</span>  <span class="mf">3.65933681</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L75</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>alpha</strong> (<em>float, optional, default=1</em>) – Alpha parameter (shape) of the gamma distribution.</li>
<li><strong>beta</strong> (<em>float, optional, default=1</em>) – Beta parameter (scale) of the gamma distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_generalized_negative_binomial">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_generalized_negative_binomial</code><span class="sig-paren">(</span><em>mu=_Null</em>, <em>alpha=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_generalized_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by
<em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_generalized_negative_binomial</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                                                        <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L133</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<em>float, optional, default=1</em>) – Mean of the negative binomial distribution.</li>
<li><strong>alpha</strong> (<em>float, optional, default=1</em>) – Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_negative_binomial">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_negative_binomial</code><span class="sig-paren">(</span><em>k=_Null</em>, <em>p=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by
<em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_negative_binomial</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                                                     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L117</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<em>int, optional, default='1'</em>) – Limit of unsuccessful experiments.</li>
<li><strong>p</strong> (<em>float, optional, default=1</em>) – Failure probability in each experiment.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_normal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_normal</code><span class="sig-paren">(</span><em>loc=_Null</em>, <em>scale=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a normal (Gaussian) distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">normal</span></code> is deprecated.</p>
</div>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.89171135</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.16881478</span><span class="p">],</span>
                                              <span class="p">[</span><span class="o">-</span><span class="mf">1.23474145</span><span class="p">,</span>  <span class="mf">1.55807114</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L62</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loc</strong> (<em>float, optional, default=0</em>) – Mean of the distribution.</li>
<li><strong>scale</strong> (<em>float, optional, default=1</em>) – Standard deviation of the distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_poisson">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_poisson</code><span class="sig-paren">(</span><em>lam=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                      <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L102</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<em>float, optional, default=1</em>) – Lambda parameter (rate) of the Poisson distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.random_uniform">
<code class="descclassname">mxnet.symbol.</code><code class="descname">random_uniform</code><span class="sig-paren">(</span><em>low=_Null</em>, <em>high=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.random_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a uniform distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">uniform</span></code> is deprecated.</p>
</div>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em>
(includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.60276335</span><span class="p">,</span>  <span class="mf">0.85794562</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">0.54488319</span><span class="p">,</span>  <span class="mf">0.84725171</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L45</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<em>float, optional, default=0</em>) – Lower bound of the distribution.</li>
<li><strong>high</strong> (<em>float, optional, default=1</em>) – Upper bound of the distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.reciprocal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">reciprocal</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reciprocal of the argument, element-wise.</p>
<p>Calculates 1/x.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">reciprocal</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.33333334</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L220</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.relu">
<code class="descclassname">mxnet.symbol.</code><code class="descname">relu</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes rectified linear.</p>
<div class="math">
\[max(features, 0)\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L18</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.repeat">
<code class="descclassname">mxnet.symbol.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>data=None</em>, <em>repeats=_Null</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeats elements of an array.</p>
<p>By default, <code class="docutils literal"><span class="pre">repeat</span></code> flattens the input array into 1-D and then repeats the
elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal"><span class="pre">axis</span></code> specifies the axis along which to perform repeat:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L499</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data array</li>
<li><strong>repeats</strong> (<em>int, required</em>) – The number of repetitions for each element.</li>
<li><strong>axis</strong> (<em>int or None, optional, default='None'</em>) – The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.reshape">
<code class="descclassname">mxnet.symbol.</code><code class="descname">reshape</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>reverse=_Null</em>, <em>target_shape=_Null</em>, <em>keep_highest=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes the input array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Reshape</span></code> is deprecated, use <code class="docutils literal"><span class="pre">reshape</span></code></p>
</div>
<p>Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4).The size of the new shape should be same as the size of the input array.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">0</span></code>  copy this dimension from the input to the output shape.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-1</span></code> infers the dimension of the output shape by using the remainder of the input dimensions
keeping the size of the new array same as that of the input array.
At most one dimension of shape can be -1.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
- input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
- input shape = (2,3,4), shape=(-1,), output shape = (24,)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-2</span></code> copy all/remainder of the input dimensions to the output shape.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
- input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
- input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-3</span></code> use the product of two consecutive dimensions of the input shape as the output dimension.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
- input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
- input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
- input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-4</span></code> split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
- input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
</pre></div>
</div>
</li>
</ul>
<p>If the argument <cite>reverse</cite> is set to 1, then the special values are inferred from right to left.</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
- with reverse=1, output shape will be (50,4).
</pre></div>
</div>
</div></blockquote>
<p>Defined in src/operator/tensor/matrix_op.cc:L88</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data to reshape.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – The target shape</li>
<li><strong>reverse</strong> (<em>boolean, optional, default=False</em>) – If true then the special values are inferred from right to left</li>
<li><strong>target_shape</strong> (<em>Shape(tuple), optional, default=()</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</li>
<li><strong>keep_highest</strong> (<em>boolean, optional, default=False</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.reverse">
<code class="descclassname">mxnet.symbol.</code><code class="descname">reverse</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">9.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L601</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data array</li>
<li><strong>axis</strong> (<em>Shape(tuple), required</em>) – The axis which to reverse elements.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.rint">
<code class="descclassname">mxnet.symbol.</code><code class="descname">rint</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.rint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer of the input.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>For input <code class="docutils literal"><span class="pre">n.5</span></code> <code class="docutils literal"><span class="pre">rint</span></code> returns <code class="docutils literal"><span class="pre">n</span></code> while <code class="docutils literal"><span class="pre">round</span></code> returns <code class="docutils literal"><span class="pre">n+1</span></code>.</li>
<li>For input <code class="docutils literal"><span class="pre">-n.5</span></code> both <code class="docutils literal"><span class="pre">rint</span></code> and <code class="docutils literal"><span class="pre">round</span></code> returns <code class="docutils literal"><span class="pre">-n-1</span></code>.</li>
</ul>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rint</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L282</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.rmsprop_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">rmsprop_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>n=None</em>, <em>lr=_Null</em>, <em>gamma1=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>clip_weights=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.rmsprop_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for <cite>RMSProp</cite> optimizer.</p>
<p><cite>RMSprop</cite> is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?</p>
<p><cite>RMSProp</cite> is similar to <cite>AdaGrad</cite>, a popular variant of <cite>SGD</cite> which adaptively
tunes the learning rate of each parameter. <cite>AdaGrad</cite> lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. <cite>RMSProp</cite> deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.</p>
<p>Define the Root Mean Square (RMS) error criterion of the gradient as
<span class="math">\(RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}\)</span>, where <span class="math">\(g\)</span> represents
gradient and <span class="math">\(E[g^2]_t\)</span> is the decaying average over past squared gradient.</p>
<p>The <span class="math">\(E[g^2]_t\)</span> is given by:</p>
<div class="math">
\[E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2\]</div>
<p>The update step is</p>
<div class="math">
\[\theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t\]</div>
<p>The RMSProp code follows the version in
<a class="reference external" href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf</a>
Tieleman &amp; Hinton, 2012.</p>
<p>Hinton suggests the momentum term <span class="math">\(\gamma\)</span> to be 0.9 and the learning rate
<span class="math">\(\eta\)</span> to be 0.001.</p>
<p>Defined in src/operator/optimizer_op.cc:L178</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>n</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – n</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>gamma1</strong> (<em>float, optional, default=0.95</em>) – The decay rate of momentum estimates.</li>
<li><strong>epsilon</strong> (<em>float, optional, default=1e-08</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>clip_weights</strong> (<em>float, optional, default=-1</em>) – Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.rmspropalex_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">rmspropalex_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>n=None</em>, <em>g=None</em>, <em>delta=None</em>, <em>lr=_Null</em>, <em>gamma1=_Null</em>, <em>gamma2=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>clip_weights=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.rmspropalex_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for RMSPropAlex optimizer.</p>
<p><cite>RMSPropAlex</cite> is non-centered version of <cite>RMSProp</cite>.</p>
<p>Define <span class="math">\(E[g^2]_t\)</span> is the decaying average over past squared gradient and
<span class="math">\(E[g]_t\)</span> is the decaying average over past gradient.</p>
<div class="math">
\[\begin{split}E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
\Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\\end{split}\]</div>
<p>The update step is</p>
<div class="math">
\[\theta_{t+1} = \theta_t + \Delta_t\]</div>
<p>The RMSPropAlex code follows the version in
<a class="reference external" href="http://arxiv.org/pdf/1308.0850v5.pdf">http://arxiv.org/pdf/1308.0850v5.pdf</a> Eq(38) - Eq(45) by Alex Graves, 2013.</p>
<p>Graves suggests the momentum term <span class="math">\(\gamma_1\)</span> to be 0.95, <span class="math">\(\gamma_2\)</span>
to be 0.9 and the learning rate <span class="math">\(\eta\)</span> to be 0.0001.</p>
<p>Defined in src/operator/optimizer_op.cc:L217</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>n</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – n</li>
<li><strong>g</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – g</li>
<li><strong>delta</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – delta</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>gamma1</strong> (<em>float, optional, default=0.95</em>) – Decay rate.</li>
<li><strong>gamma2</strong> (<em>float, optional, default=0.9</em>) – Decay rate.</li>
<li><strong>epsilon</strong> (<em>float, optional, default=1e-08</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>clip_weights</strong> (<em>float, optional, default=-1</em>) – Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.round">
<code class="descclassname">mxnet.symbol.</code><code class="descname">round</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">round</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L266</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.rsqrt">
<code class="descclassname">mxnet.symbol.</code><code class="descname">rsqrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.rsqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse square-root value of the input.</p>
<div class="math">
\[rsqrt(x) = 1/\sqrt{x}\]</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rsqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.33333334</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L383</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_exponential">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_exponential</code><span class="sig-paren">(</span><em>lam=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array.
Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>lam = [ 1.0, 8.5 ]

// Draw a single sample for each distribution
sample_exponential(lam) = [ 0.51837951,  0.09994757]

// Draw a vector containing two samples for each distribution
sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
                                      [ 0.09994757,  0.50447971]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L370</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Lambda (rate) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_gamma">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_gamma</code><span class="sig-paren">(</span><em>alpha=None</em>, <em>beta=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>alpha = [ 0.0, 2.5 ]
beta = [ 1.0, 0.7 ]

// Draw a single sample for each distribution
sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]

// Draw a vector containing two samples for each distribution
sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
                                        [ 2.25797319,  1.70734084]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L368</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>alpha</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Alpha (shape) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Beta (scale) parameters of the distributions.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_generalized_negative_binomial">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_generalized_negative_binomial</code><span class="sig-paren">(</span><em>mu=None</em>, <em>alpha=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_generalized_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>mu = [ 2.0, 2.5 ]
alpha = [ 1.0, 0.1 ]

// Draw a single sample for each distribution
sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]

// Draw a vector containing two samples for each distribution
sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
                                                              [ 3.,  1.]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L379</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Means of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>alpha</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Alpha (dispersion) parameters of the distributions.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_multinomial">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_multinomial</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>get_prob=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_multinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where
<em>k</em> is the number of possible outcomes of each multinomial distribution. This
operator will draw <em>shape</em> samples from each distribution. If shape is empty
one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to
1 along its last axis.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]

// Draw a single sample for each distribution
sample_multinomial(probs) = [3, 0]

// Draw a vector containing two samples for each distribution
sample_multinomial(probs, shape=(2)) = [[4, 2],
                                        [0, 0]]

// requests log likelihood
sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Distribution probabilities. Must sum to one on the last axis.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>get_prob</strong> (<em>boolean, optional, default=False</em>) – Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><strong>dtype</strong> (<em>{'int32'},optional, default='int32'</em>) – DType of the output in case this can’t be inferred. Only support int32 for now.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_negative_binomial">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_negative_binomial</code><span class="sig-paren">(</span><em>k=None</em>, <em>p=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>k = [ 20, 49 ]
p = [ 0.4 , 0.77 ]

// Draw a single sample for each distribution
sample_negative_binomial(k, p) = [ 15.,  16.]

// Draw a vector containing two samples for each distribution
sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
                                             [ 16.,  12.]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L375</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Limits of unsuccessful experiments.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>p</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Failure probabilities in each experiment.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_normal">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_normal</code><span class="sig-paren">(</span><em>mu=None</em>, <em>sigma=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>mu = [ 0.0, 2.5 ]
sigma = [ 1.0, 3.7 ]

// Draw a single sample for each distribution
sample_normal(mu, sigma) = [-0.56410581,  0.95934606]

// Draw a vector containing two samples for each distribution
sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
                                       [ 0.95934606,  4.48287058]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L365</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Means of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>sigma</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Standard deviations of the distributions.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_poisson">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_poisson</code><span class="sig-paren">(</span><em>lam=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array.
Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>lam = [ 1.0, 8.5 ]

// Draw a single sample for each distribution
sample_poisson(lam) = [  0.,  13.]

// Draw a vector containing two samples for each distribution
sample_poisson(lam, shape=(2)) = [[  0.,   4.],
                                  [ 13.,   8.]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L372</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Lambda (rate) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sample_uniform">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sample_uniform</code><span class="sig-paren">(</span><em>low=None</em>, <em>high=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sample_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>low = [ 0.0, 2.5 ]
high = [ 1.0, 3.7 ]

// Draw a single sample for each distribution
sample_uniform(low, high) = [ 0.40451524,  3.18687344]

// Draw a vector containing two samples for each distribution
sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
                                        [ 3.18687344,  3.68352246]]
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L363</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Lower bounds of the distributions.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>high</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Upper bounds of the distributions.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sgd_mom_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sgd_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:</p>
<div class="math">
\[\begin{split}v_1 = \alpha * \nabla J(W_0)\\
v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
W_t = W_{t-1} + v_t\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="n">weight</span> <span class="o">+=</span> <span class="n">v</span>
</pre></div>
</div>
<p>Where the parameter <code class="docutils literal"><span class="pre">momentum</span></code> is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/optimizer_op.cc:L55</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Momentum</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float, optional, default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sgd_update">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sgd_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>lr=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L25</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Gradient</li>
<li><strong>lr</strong> (<em>float, required</em>) – Learning rate</li>
<li><strong>wd</strong> (<em>float, optional, default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float, optional, default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float, optional, default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sigmoid">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sigmoid</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes sigmoid of x element-wise.</p>
<div class="math">
\[y = 1 / (1 + exp(-x))\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L36</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sign">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sign</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sign of the input.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">sign</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L251</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sin">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise sine of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L448</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sinh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sinh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic sine of the input array, computed element-wise.</p>
<div class="math">
\[sinh(x) = 0.5\times(exp(x) - exp(-x))\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L599</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.slice">
<code class="descclassname">mxnet.symbol.</code><code class="descname">slice</code><span class="sig-paren">(</span><em>data=None</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a contiguous region of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">crop</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">slice</span></code> instead.</p>
</div>
<p>This function returns a sliced continuous region of the array between the indices given
by <cite>begin</cite> and <cite>end</cite>.</p>
<p>For an input array of <cite>n</cite> dimensions, slice operation with <code class="docutils literal"><span class="pre">begin=(b_0,</span> <span class="pre">b_1...b_n-1)</span></code> indices
and <code class="docutils literal"><span class="pre">end=(e_1,</span> <span class="pre">e_2,</span> <span class="pre">...</span> <span class="pre">e_n)</span></code> indices will result in an array with the shape
<code class="docutils literal"><span class="pre">(e_1-b_0,</span> <span class="pre">...,</span> <span class="pre">e_n-b_n-1)</span></code>.</p>
<p>The resulting array’s <em>k</em>-th dimension contains elements
from the <em>k</em>-th dimension of the input array with the open range <code class="docutils literal"><span class="pre">[b_k,</span> <span class="pre">e_k)</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L257</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>begin</strong> (<em>Shape(tuple), required</em>) – starting indices for the slice operation, supports negative indices.</li>
<li><strong>end</strong> (<em>Shape(tuple), required</em>) – ending indices for the slice operation, supports negative indices.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.slice_axis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">slice_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.slice_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices along a given axis.</p>
<p>Returns an array slice along a given <cite>axis</cite> starting from the <cite>begin</cite> index
to the <cite>end</cite> index.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">begin</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                                           <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">],</span>
                                           <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L337</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>axis</strong> (<em>int, required</em>) – Axis along which to be sliced, supports negative indexes.</li>
<li><strong>begin</strong> (<em>int, required</em>) – The beginning index along the axis to be sliced,  supports negative indexes.</li>
<li><strong>end</strong> (<em>int or None, required</em>) – The ending index along the axis to be sliced,  supports negative indexes.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.smooth_l1">
<code class="descclassname">mxnet.symbol.</code><code class="descname">smooth_l1</code><span class="sig-paren">(</span><em>data=None</em>, <em>scalar=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.smooth_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Smooth L1 Loss(lhs, scalar) by summing</p>
<div class="math">
\[\begin{split}f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \text{if }x < 1/\sigma^2\\
|x|-0.5/\sigma^2,&amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>where <span class="math">\(x\)</span> is an element of the tensor <em>lhs</em> and <span class="math">\(\sigma\)</span> is the scalar.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">smooth_l1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L79</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – source input</li>
<li><strong>scalar</strong> (<em>float</em>) – scalar input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.softmax">
<code class="descclassname">mxnet.symbol.</code><code class="descname">softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the softmax function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.</p>
<div class="math">
\[softmax(\mathbf{z})_j = \frac{e^{z_j}}{\sum_{k=1}^K e^{z_k}}\]</div>
<p>for <span class="math">\(j = 1, ..., K\)</span></p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 1.  1.  1.]
     [ 1.  1.  1.]]

softmax(x,axis=0) = [[ 0.5  0.5  0.5]
                     [ 0.5  0.5  0.5]]

softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
                     [ 0.33333334,  0.33333334,  0.33333334]]
</pre></div>
</div>
<p>Defined in src/operator/nn/softmax.cc:L35</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>axis</strong> (<em>int, optional, default='-1'</em>) – The axis along which to compute softmax.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.softmax_cross_entropy">
<code class="descclassname">mxnet.symbol.</code><code class="descname">softmax_cross_entropy</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.softmax_cross_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate cross entropy of softmax output and one-hot label.</p>
<ul>
<li><p class="first">This operator computes the cross entropy in two steps:
- Applies softmax function on the input array.
- Computes and returns the cross entropy loss between the softmax output and the labels.</p>
</li>
<li><p class="first">The softmax function and cross entropy loss is given by:</p>
<ul class="simple">
<li>Softmax Function:</li>
</ul>
<div class="math">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<ul class="simple">
<li>Cross Entropy Function:</li>
</ul>
<div class="math">
\[\text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)\]</div>
</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

<span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.09003057</span><span class="p">,</span> <span class="mf">0.24472848</span><span class="p">,</span> <span class="mf">0.66524094</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">0.97962922</span><span class="p">,</span> <span class="mf">0.01794253</span><span class="p">,</span> <span class="mf">0.00242826</span><span class="p">]]</span>

<span class="n">softmax_cross_entropy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.66524084</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.97962922</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.4281871</span>
</pre></div>
</div>
<p>Defined in src/operator/loss_binary_op.cc:L40</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input label</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sort">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sort</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>is_ascend=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sorted copy of an input array along the given axis.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 1, 4],
     [ 3, 1]]

// sorts along the last axis
sort(x) = [[ 1.,  4.],
           [ 1.,  3.]]

// flattens and then sorts
sort(x) = [ 1.,  1.,  3.,  4.]

// sorts along the first axis
sort(x, axis=0) = [[ 1.,  1.],
                   [ 3.,  4.]]

// in a descend order
sort(x, is_ascend=0) = [[ 4.,  1.],
                        [ 3.,  1.]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L107</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int or None, optional, default='-1'</em>) – Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><strong>is_ascend</strong> (<em>boolean, optional, default=True</em>) – Whether to sort in ascending or descending order.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.split">
<code class="descclassname">mxnet.symbol.</code><code class="descname">split</code><span class="sig-paren">(</span><em>data=None</em>, <em>num_outputs=_Null</em>, <em>axis=_Null</em>, <em>squeeze_axis=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits an array along a particular axis into multiple sub-arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">SliceChannel</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">split</span></code> instead.</p>
</div>
<p><strong>Note</strong> that <cite>num_outputs</cite> should evenly divide the length of the axis
along which to split the array.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x  = [[[ 1.]
       [ 2.]]
      [[ 3.]
       [ 4.]]
      [[ 5.]
       [ 6.]]]
x.shape = (3, 2, 1)

y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
y = [[[ 1.]]
     [[ 3.]]
     [[ 5.]]]

    [[[ 2.]]
     [[ 4.]]
     [[ 6.]]]

y[0].shape = (3, 1, 1)

z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
z = [[[ 1.]
      [ 2.]]]

    [[[ 3.]
      [ 4.]]]

    [[[ 5.]
      [ 6.]]]

z[0].shape = (1, 2, 1)
</pre></div>
</div>
<p><cite>squeeze_axis=1</cite> removes the axis with length 1 from the shapes of the output arrays.
<strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">1</span></code> removes axis with length 1 only
along the <cite>axis</cite> which it is split.
Also <cite>squeeze_axis</cite> can be set to true only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
z = [[ 1.]
     [ 2.]]

    [[ 3.]
     [ 4.]]

    [[ 5.]
     [ 6.]]
z[0].shape = (2 ,1 )
</pre></div>
</div>
<p>Defined in src/operator/slice_channel.cc:L88</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>num_outputs</strong> (<em>int, required</em>) – Number of splits. Note that this should evenly divide the length of the <cite>axis</cite>.</li>
<li><strong>axis</strong> (<em>int, optional, default='1'</em>) – Axis along which to split.</li>
<li><strong>squeeze_axis</strong> (<em>boolean, optional, default=False</em>) – If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">true</span></code> removes axis with length 1 only along the <cite>axis</cite> which it is split. Also <cite>squeeze_axis</cite> can be set to <code class="docutils literal"><span class="pre">true</span></code> only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sqrt">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise square-root value of the input.</p>
<div class="math">
\[\textrm{sqrt}(x) = \sqrt{x}\]</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L365</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.square">
<code class="descclassname">mxnet.symbol.</code><code class="descname">square</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise squared value of the input.</p>
<div class="math">
\[square(x) = x^2\]</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">square</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L347</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.stack">
<code class="descclassname">mxnet.symbol.</code><code class="descname">stack</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along a new axis.</p>
<p>The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>This function support variable length of positional input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>Symbol[]</em>) – List of arrays to stack</li>
<li><strong>axis</strong> (<em>int, optional, default='0'</em>) – The axis in the result array along which the input arrays are stacked.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.stop_gradient">
<code class="descclassname">mxnet.symbol.</code><code class="descname">stop_gradient</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.stop_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>v1 = [1, 2]
v2 = [0, 1]
a = Variable('a')
b = Variable('b')
b_stop_grad = stop_gradient(3 * b)
loss = MakeLoss(b_stop_grad + a)

executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
executor.forward(is_train=True, a=v1, b=v2)
executor.outputs
[ 1.  5.]

executor.backward()
executor.grad_arrays
[ 0.  0.]
[ 1.  1.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L99</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sum">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sum</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>sum</cite> and <cite>sum_axis</cite> are equivalent.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>data = [[[1,2],[2,3],[1,3]],
        [[1,4],[4,3],[5,2]],
        [[7,1],[7,2],[7,3]]]

sum(data, axis=1)
[[  4.   8.]
 [ 10.   9.]
 [ 21.   6.]]

sum(data, axis=[1,2])
[ 12.  19.  27.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L51</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.sum_axis">
<code class="descclassname">mxnet.symbol.</code><code class="descname">sum_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.sum_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>sum</cite> and <cite>sum_axis</cite> are equivalent.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>data = [[[1,2],[2,3],[1,3]],
        [[1,4],[4,3],[5,2]],
        [[7,1],[7,2],[7,3]]]

sum(data, axis=1)
[[  4.   8.]
 [ 10.   9.]
 [ 21.   6.]]

sum(data, axis=[1,2])
[ 12.  19.  27.]
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L51</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape(tuple), optional, default=()</em>) – <p>The axis or axes along which to perform the reduction.</p>
<p>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.</p>
<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</li>
<li><strong>keepdims</strong> (<em>boolean, optional, default=False</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean, optional, default=False</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.swapaxes">
<code class="descclassname">mxnet.symbol.</code><code class="descname">swapaxes</code><span class="sig-paren">(</span><em>data=None</em>, <em>dim1=_Null</em>, <em>dim2=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchanges two axes of an array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span> x = [[1, 2, 3]])
 swapaxes(x, 0, 1) = [[ 1],
                      [ 2],
                      [ 3]]

 x = [[[ 0, 1],
       [ 2, 3]],
      [[ 4, 5],
       [ 6, 7]]]  // (2,2,2) array

swapaxes(x, 0, 2) = [[[ 0, 4],
                      [ 2, 6]],
                     [[ 1, 5],
                      [ 3, 7]]]
</pre></div>
</div>
<p>Defined in src/operator/swapaxis.cc:L51</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input array.</li>
<li><strong>dim1</strong> (<em>int (non-negative), optional, default=0</em>) – the first axis to be swapped.</li>
<li><strong>dim2</strong> (<em>int (non-negative), optional, default=0</em>) – the second axis to be swapped.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.take">
<code class="descclassname">mxnet.symbol.</code><code class="descname">take</code><span class="sig-paren">(</span><em>a=None</em>, <em>indices=None</em>, <em>axis=_Null</em>, <em>mode=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes elements from an input array along the given axis.</p>
<p>This function slices the input array along a particular axis with the provided indices.</p>
<p>Given an input array with shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">d2)</span></code> and indices with shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1)</span></code>, the output
will have shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1,</span> <span class="pre">d1,</span> <span class="pre">d2)</span></code>, computed by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],:,:]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><cite>axis</cite>- Only slicing along axis 0 is supported for now.</li>
<li><cite>mode</cite>- Only <cite>clip</cite> mode is supported for now.</li>
</ul>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 1.,  2.],
     [ 3.,  4.],
     [ 5.,  6.]]

// takes elements with specified indices along axis 0
take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
                           [ 3.,  4.]],

                          [[ 3.,  4.],
                           [ 5.,  6.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L117</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The indices of the values to be extracted.</li>
<li><strong>axis</strong> (<em>int, optional, default='0'</em>) – The axis of input array to be taken.</li>
<li><strong>mode</strong> (<em>{'clip', 'raise', 'wrap'},optional, default='clip'</em>) – Specify how out-of-bound indices bahave. “clip” means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  “wrap” means to wrap around.  “raise” means to raise an error.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.tan">
<code class="descclassname">mxnet.symbol.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise tangent of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[tan([0, \pi/4, \pi/2]) = [0, 1, -inf]\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L507</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.tanh">
<code class="descclassname">mxnet.symbol.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic tangent of the input array, computed element-wise.</p>
<div class="math">
\[tanh(x) = sinh(x) / cosh(x)\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L627</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.tile">
<code class="descclassname">mxnet.symbol.</code><code class="descname">tile</code><span class="sig-paren">(</span><em>data=None</em>, <em>reps=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeats the whole array multiple times.</p>
<p>If <code class="docutils literal"><span class="pre">reps</span></code> has length <em>d</em>, and input array has dimension of <em>n</em>. There are
there cases:</p>
<ul>
<li><p class="first"><strong>n=d</strong>. Repeat <em>i</em>-th dimension of the input by <code class="docutils literal"><span class="pre">reps[i]</span></code> times:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>n>d</strong>. <code class="docutils literal"><span class="pre">reps</span></code> is promoted to length <em>n</em> by pre-pending 1’s to it. Thus for
an input shape <code class="docutils literal"><span class="pre">(2,3)</span></code>, <code class="docutils literal"><span class="pre">repos=(2,)</span></code> is treated as <code class="docutils literal"><span class="pre">(1,2)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>n<d</strong>. The input is promoted to be d-dimensional by prepending new axes. So a
shape <code class="docutils literal"><span class="pre">(2,2)</span></code> array is promoted to <code class="docutils literal"><span class="pre">(1,2,2)</span></code> for 3-D replication:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]],</span>

                         <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]]</span>
</pre></div>
</div>
</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L560</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Input data array</li>
<li><strong>reps</strong> (<em>Shape(tuple), required</em>) – The number of times for repeating the tensor a. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim < d, a is promoted to be d-dimensional by prepending new axes. If a.ndim > d, reps is promoted to a.ndim by pre-pending 1’s to it.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.topk">
<code class="descclassname">mxnet.symbol.</code><code class="descname">topk</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>k=_Null</em>, <em>ret_typ=_Null</em>, <em>is_ascend=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.topk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top <em>k</em> elements in an input array along the given axis.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>x = [[ 0.3,  0.2,  0.4],
     [ 0.1,  0.3,  0.2]]

// returns an index of the largest element on last axis
topk(x) = [[ 2.],
           [ 1.]]

// returns the value of top-2 largest elements on last axis
topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],
                                 [ 0.3,  0.2]]

// returns the value of top-2 smallest elements on last axis
topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],
                                             [ 0.1 ,  0.2]]

// returns the value of top-2 largest elements on axis 0
topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],
                                         [ 0.1,  0.2,  0.2]]

// flattens and then returns list of both values and indices
topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L44</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int or None, optional, default='-1'</em>) – Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</li>
<li><strong>k</strong> (<em>int, optional, default='1'</em>) – Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k < 1.</li>
<li><strong>ret_typ</strong> (<em>{'both', 'indices', 'mask', 'value'},optional, default='indices'</em>) – The return type.
“value” means to return the top k values, “indices” means to return the indices of the top k values, “mask” means to return a mask array containing 0 and 1. 1 means the top k values. “both” means to return a list of both values and indices of top k elements.</li>
<li><strong>is_ascend</strong> (<em>boolean, optional, default=False</em>) – Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.transpose">
<code class="descclassname">mxnet.symbol.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>data=None</em>, <em>axes=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutes the dimensions of an array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]],</span>

     <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]],</span>

                <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]],</span>

                              <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L177</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – Source input</li>
<li><strong>axes</strong> (<em>Shape(tuple), optional, default=()</em>) – Target axis order. By default the axes will be inverted.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.trunc">
<code class="descclassname">mxnet.symbol.</code><code class="descname">trunc</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">trunc</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op.cc:L322</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input array.</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.uniform">
<code class="descclassname">mxnet.symbol.</code><code class="descname">uniform</code><span class="sig-paren">(</span><em>low=_Null</em>, <em>high=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a uniform distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">uniform</span></code> is deprecated.</p>
</div>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em>
(includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">random_uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.60276335</span><span class="p">,</span>  <span class="mf">0.85794562</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">0.54488319</span><span class="p">,</span>  <span class="mf">0.84725171</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L45</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<em>float, optional, default=0</em>) – Lower bound of the distribution.</li>
<li><strong>high</strong> (<em>float, optional, default=1</em>) – Upper bound of the distribution.</li>
<li><strong>shape</strong> (<em>Shape(tuple), optional, default=()</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string, optional, default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None', 'float16', 'float32', 'float64'},optional, default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.where">
<code class="descclassname">mxnet.symbol.</code><code class="descname">where</code><span class="sig-paren">(</span><em>condition=None</em>, <em>x=None</em>, <em>y=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y, depending on the elements from condition are true or false. x and y must have the same shape. If condition has the same shape as x, each element in the output array is from x if the corresponding element in the condition is true, and from y if false. If condition does not have the same shape as x, it must be a 1D array whose size is the same as x’s first dimension size. Each row of the output array is from x’s row if the corresponding element from condition is true, and from y’s row if false.</p>
<p>From:src/operator/tensor/control_flow_op.cc:21</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>condition</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – condition array</li>
<li><strong>x</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – </li>
<li><strong>y</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – </li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.symbol.zeros_like">
<code class="descclassname">mxnet.symbol.</code><code class="descname">zeros_like</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=None</em>, <em>attr=None</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.symbol.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type
as the input array.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a>) – The input</li>
<li><strong>name</strong> (<em>string, optional.</em>) – Name of the resulting symbol.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol">Symbol</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<script>auto_index("api-reference");</script></div>
</div>
<div class="container">
<div class="footer">
<p> © 2015-2017 DMLC. All rights reserved. </p>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar rightsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li><a class="reference internal" href="#">Symbol API</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-symbol-class">The <code class="docutils literal"><span class="pre">Symbol</span></code> class</a><ul>
<li><a class="reference internal" href="#composition">Composition</a><ul>
<li><a class="reference internal" href="#arithmetic-operations">Arithmetic operations</a></li>
<li><a class="reference internal" href="#comparison-operators">Comparison operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#query-information">Query information</a></li>
<li><a class="reference internal" href="#get-internal-and-output-symbol">Get internal and output symbol</a></li>
<li><a class="reference internal" href="#inference-type-and-shape">Inference type and shape</a></li>
<li><a class="reference internal" href="#bind">Bind</a></li>
<li><a class="reference internal" href="#save">Save</a></li>
</ul>
</li>
<li><a class="reference internal" href="#symbol-creation-routines">Symbol creation routines</a></li>
<li><a class="reference internal" href="#symbol-manipulation-routines">Symbol manipulation routines</a><ul>
<li><a class="reference internal" href="#changing-shape-and-type">Changing shape and type</a></li>
<li><a class="reference internal" href="#expanding-elements">Expanding elements</a></li>
<li><a class="reference internal" href="#rearranging-elements">Rearranging elements</a></li>
<li><a class="reference internal" href="#joining-and-splitting-symbols">Joining and splitting symbols</a></li>
<li><a class="reference internal" href="#indexing-routines">Indexing routines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mathematical-functions">Mathematical functions</a><ul>
<li><a class="reference internal" href="#arithmetic-operations">Arithmetic operations</a></li>
<li><a class="reference internal" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-functions">Hyperbolic functions</a></li>
<li><a class="reference internal" href="#reduce-functions">Reduce functions</a></li>
<li><a class="reference internal" href="#rounding">Rounding</a></li>
<li><a class="reference internal" href="#exponents-and-logarithms">Exponents and logarithms</a></li>
<li><a class="reference internal" href="#powers">Powers</a></li>
<li><a class="reference internal" href="#logic-functions">Logic functions</a></li>
<li><a class="reference internal" href="#random-sampling">Random sampling</a></li>
<li><a class="reference internal" href="#sorting-and-searching">Sorting and searching</a></li>
<li><a class="reference internal" href="#linear-algebra">Linear Algebra</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a class="reference internal" href="#neural-network">Neural network</a><ul>
<li><a class="reference internal" href="#basic">Basic</a></li>
<li><a class="reference internal" href="#more">More</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div> <!-- pagename != index -->
<script crossorigin="anonymous" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<script src="../../_static/js/sidebar.js" type="text/javascript"></script>
<script src="../../_static/js/search.js" type="text/javascript"></script>
<script src="../../_static/js/navbar.js" type="text/javascript"></script>
<script src="../../_static/js/clipboard.min.js" type="text/javascript"></script>
<script src="../../_static/js/copycode.js" type="text/javascript"></script>
<script type="text/javascript">
        $('body').ready(function () {
            $('body').css('visibility', 'visible');
        });
    </script>
</div></body>
</html>